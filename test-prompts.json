[
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/dto/automation-request.dto.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/dto/automation-request.dto.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste automation-request.dto.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/dto/automation-request.dto.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './automation-request.dto';\n\ndescribe('automation-request.dto coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './automation-request.dto';\n\ndescribe('automation-request.dto page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/dto/automation-request.dto.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/dto/clipboard-request.dto.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/dto/clipboard-request.dto.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste clipboard-request.dto.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/dto/clipboard-request.dto.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './clipboard-request.dto';\n\ndescribe('clipboard-request.dto coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './clipboard-request.dto';\n\ndescribe('clipboard-request.dto page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/dto/clipboard-request.dto.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/dto/keyboard-request.dto.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/dto/keyboard-request.dto.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste keyboard-request.dto.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/dto/keyboard-request.dto.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './keyboard-request.dto';\n\ndescribe('keyboard-request.dto coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './keyboard-request.dto';\n\ndescribe('keyboard-request.dto page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/dto/keyboard-request.dto.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/services/clipboard.service.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/services/clipboard.service.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste clipboard.service.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/services/clipboard.service.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './clipboard.service';\n\ndescribe('clipboard.service coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './clipboard.service';\n\ndescribe('clipboard.service page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/services/clipboard.service.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/services/event-buffer.service.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/services/event-buffer.service.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste event-buffer.service.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/services/event-buffer.service.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './event-buffer.service';\n\ndescribe('event-buffer.service coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './event-buffer.service';\n\ndescribe('event-buffer.service page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/services/event-buffer.service.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/services/event-dispatcher.service.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/services/event-dispatcher.service.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste event-dispatcher.service.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/services/event-dispatcher.service.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './event-dispatcher.service';\n\ndescribe('event-dispatcher.service coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './event-dispatcher.service';\n\ndescribe('event-dispatcher.service page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/services/event-dispatcher.service.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/services/keyboard.service.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/services/keyboard.service.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste keyboard.service.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/services/keyboard.service.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './keyboard.service';\n\ndescribe('keyboard.service coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './keyboard.service';\n\ndescribe('keyboard.service page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/services/keyboard.service.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/services/mouse.service.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/services/mouse.service.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste mouse.service.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/services/mouse.service.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './mouse.service';\n\ndescribe('mouse.service coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './mouse.service';\n\ndescribe('mouse.service page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/services/mouse.service.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/services/recorder-listener.service.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/services/recorder-listener.service.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste recorder-listener.service.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/services/recorder-listener.service.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './recorder-listener.service';\n\ndescribe('recorder-listener.service coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './recorder-listener.service';\n\ndescribe('recorder-listener.service page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/services/recorder-listener.service.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/application/services/screen.service.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/application/services/screen.service.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste screen.service.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/application/services/screen.service.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './screen.service';\n\ndescribe('screen.service coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './screen.service';\n\ndescribe('screen.service page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/application/services/screen.service.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/config/dependency-injection.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/config/dependency-injection.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste dependency-injection.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/config/dependency-injection.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './dependency-injection';\n\ndescribe('dependency-injection coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './dependency-injection';\n\ndescribe('dependency-injection page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/config/dependency-injection.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/config/environment.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/config/environment.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste environment.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/config/environment.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './environment';\n\ndescribe('environment coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './environment';\n\ndescribe('environment page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/config/environment.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/config/input-events.config.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/config/input-events.config.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste input-events.config.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/config/input-events.config.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './input-events.config';\n\ndescribe('input-events.config coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './input-events.config';\n\ndescribe('input-events.config page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/config/input-events.config.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/config/keyboard.config.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/config/keyboard.config.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste keyboard.config.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/config/keyboard.config.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './keyboard.config';\n\ndescribe('keyboard.config coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './keyboard.config';\n\ndescribe('keyboard.config page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/config/keyboard.config.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/config/logger.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/config/logger.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste logger.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/config/logger.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './logger';\n\ndescribe('logger coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './logger';\n\ndescribe('logger page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/config/logger.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/config/mouse.config.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/config/mouse.config.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste mouse.config.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/config/mouse.config.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './mouse.config';\n\ndescribe('mouse.config coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './mouse.config';\n\ndescribe('mouse.config page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/config/mouse.config.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/config/recorder.config.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/config/recorder.config.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste recorder.config.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/config/recorder.config.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './recorder.config';\n\ndescribe('recorder.config coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './recorder.config';\n\ndescribe('recorder.config page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/config/recorder.config.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/domain/entities/command-result.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/domain/entities/command-result.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste command-result.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/domain/entities/command-result.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './command-result';\n\ndescribe('command-result coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './command-result';\n\ndescribe('command-result page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/domain/entities/command-result.ts.test.ts --coverage\n</answer>",
  "<instructions>\nCrie testes Jest para o arquivo TypeScript localizado em src/domain/entities/mouse-action.ts seguindo uma abordagem de maximização rápida de coverage, priorizando velocidade sobre qualidade detalhada.\n\nIMPORTANTE: Antes de começar a criar qualquer teste, SEMPRE leia o arquivo know-how.txt se ele existir para aproveitar o conhecimento acumulado sobre padrões de teste que funcionaram anteriormente.\n\nDurante o processo de teste, sempre que um teste falhar e você conseguir fazê-lo passar, adicione esse conhecimento ao arquivo know-how.txt de forma explicativa (não literal/código), descrevendo:\n- O problema encontrado\n- A solução aplicada\n- O padrão ou técnica que funcionou\n- Quando aplicar essa solução novamente\n\nPADRÃO DO PROJETO: Este projeto usa *.test.tsx (não .spec.tsx) e segue convenções específicas documentadas no know-how.txt\n</instructions>\n\n<context>\n- Framework de teste: Jest com TypeScript\n- Ambiente: Node.js com ts-jest\n- Objetivo: Atingir mínimo de 80% de coverage rapidamente\n- Estratégia: Testes minimalistas focados em execução de código\n- Arquivo alvo: src/domain/entities/mouse-action.ts\n- Base de conhecimento: know-how.txt (ler antes de começar)\n</context>\n\n<approach>\n0. Preparação inicial\n    - SEMPRE ler know-how.txt antes de começar (se existir)\n    - Aplicar conhecimentos prévios relevantes ao tipo de arquivo\n\n1. Analisar estrutura do arquivo TypeScript\n    - Identificar todas as exports (funções, classes, componentes)\n    - Mapear branches e statements para coverage\n    - Determinar tipo de módulo (React, utilitário, serviço)\n\n2. Criar arquivo de teste mouse-action.test.ts\n    - Usar convenção de nomenclatura padrão\n    - Localizar no mesmo diretório do arquivo original\n\n3. Implementar estratégias de teste por tipo:\n    - Componentes React: render() básico com props mínimas\n    - Funções: execução com try/catch para múltiplos parâmetros\n    - Classes: instanciação e chamada de todos os métodos\n    - Módulos: importação dinâmica de todas as exports\n\n4. Executar testes iterativamente com aprendizado\n    - Rodar: npm test src/domain/entities/mouse-action.ts.test.ts\n    - Identificar falhas\n    - Adicionar mocks mínimos necessários\n    - Quando um teste passar após falhar: documentar solução em know-how.txt\n    - Repetir até 100% de sucesso\n\n5. Verificar coverage\n    - Executar com --coverage\n    - Confirmar mínimo de 80%\n    - Se coverage baixo: consultar know-how.txt para estratégias adicionais\n</approach>\n\n<examples>\n<example type=\"react_component\">\n// Button.tsx\nexport const Button = ({ onClick, children }) => (\n  <button onClick={onClick}>{children}</button>\n);\n\n// Button.test.tsx\nimport { render } from '@testing-library/react';\nimport { Button } from './Button';\n\ndescribe('Button', () => {\n  test('renders', () => {\n    const { unmount } = render(<Button onClick={() => {}}>Test</Button>);\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</example>\n\n<example type=\"utility_functions\">\n// utils.ts\nexport const calculate = (a: number, b: number) => a * b;\nexport const validate = (email: string) => email.includes('@');\n\n// utils.test.ts\nimport * as utils from './utils';\n\ntest('executes all functions', () => {\n  Object.values(utils).forEach(fn => {\n    if (typeof fn === 'function') {\n      try { fn(); } catch {}\n      try { fn('test', 123); } catch {}\n    }\n  });\n});\n</example>\n\n<example type=\"class\">\n// service.ts\nexport class UserService {\n  getUser(id: string) { /* implementation */ }\n  createUser(data: any) { /* implementation */ }\n}\n\n// service.test.ts\nimport { UserService } from './service';\n\ntest('UserService coverage', () => {\n  const service = new UserService();\n  ['getUser', 'createUser'].forEach(method => {\n    try { service[method]('test', {}); } catch {}\n  });\n});\n</example>\n</examples>\n\n<templates>\n<template name=\"universal_test\">\nimport { render } from '@testing-library/react';\nimport * as module from './mouse-action';\n\ndescribe('mouse-action coverage', () => {\n  // Para componentes React\n  test('renders component', () => {\n    const Component = module.default || module.[ComponentName];\n    const { unmount } = render(<Component {...{}} />);\n    expect(() => unmount()).not.toThrow();\n  });\n\n  // Para funções utilitárias\n  test('executes all functions', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && !value.prototype) {\n        try {\n          value();\n          value('test', 123, {}, []);\n          value(null, undefined, false);\n        } catch {}\n      }\n    });\n  });\n\n  // Para classes\n  test('instantiates classes', () => {\n    Object.entries(module).forEach(([key, value]) => {\n      if (typeof value === 'function' && value.prototype) {\n        try {\n          const instance = new value({} as any);\n          Object.getOwnPropertyNames(Object.getPrototypeOf(instance))\n            .filter(m => m !== 'constructor')\n            .forEach(method => {\n              try { instance[method](); } catch {}\n              try { instance[method]('test', {}); } catch {}\n            });\n        } catch {}\n      }\n    });\n  });\n});\n</template>\n\n<template name=\"page_test\">\n// Para arquivos em src/pages/*\njest.mock('templates/[template-name]', () => ({\n  [TemplateName]: (props: any) => <div data-testid=\"[template-name]\" {...props}>Mock Template</div>\n}));\n\nimport { render } from '@testing-library/react';\nimport Page from './mouse-action';\n\ndescribe('mouse-action page', () => {\n  test('renders template', () => {\n    const { getByTestId, unmount } = render(<Page />);\n    expect(getByTestId('[template-name]')).toBeInTheDocument();\n    expect(() => unmount()).not.toThrow();\n  });\n});\n</template>\n</templates>\n\n<error_handling>\n- Mock ausente: Adicione mock mínimo ou use 'as any'\n- Props obrigatórias: Forneça valores vazios ({}, [], '')\n- Dependências externas: Mock com jest.mock()\n- Hooks React: Envolva em componente wrapper\n- Async/await: Use try/catch sem await\n- Contexts: Sempre mockar com jest.spyOn antes de render\n- Router: Mock next/router com valores default completos\n</error_handling>\n\n<project_patterns>\nPadrões específicos do projeto web-agendamento-digital:\n\n1. **Nomenclatura**: Sempre use *.test.tsx (nunca .spec.tsx)\n2. **Estrutura**: describe() envolvendo todos os tests\n3. **Cleanup**: Sempre testar unmount sem erros\n4. **Pages**: Mock simples do template com data-testid\n5. **Hooks**: Teste com componente wrapper inline\n6. **Coverage**: Use test.each para múltiplas configurações\n7. **Mocks comuns**:\n   - next/router: sempre com push, pathname, query, asPath\n   - contexts: usar jest.spyOn com useContext\n   - localStorage: mock global no setup\n</project_patterns>\n\n<knowledge_management>\nAo trabalhar com know-how.txt:\n\n1. Leitura inicial:\n   - Verificar se know-how.txt existe antes de começar\n   - Extrair padrões relevantes para o tipo de arquivo atual\n   - Aplicar soluções conhecidas preventivamente\n\n2. Documentação de aprendizados:\n   - Quando um teste falhar e for corrigido, adicionar ao know-how.txt:\n     * Contexto: tipo de arquivo/componente testado\n     * Erro encontrado: mensagem e causa raiz\n     * Solução aplicada: estratégia que funcionou\n     * Aplicabilidade: quando usar essa solução novamente\n   \n3. Formato de entrada no know-how.txt:\n   \n   ## [Data] - [Tipo de arquivo]\n   **Problema**: Descrição do erro ou falha\n   **Contexto**: Tipo de componente/função/classe\n   **Solução**: Como foi resolvido\n   **Quando aplicar**: Situações similares onde esta solução é útil\n   ---\n\n4. Evolução contínua:\n   - Cada novo teste bem-sucedido enriquece a base\n   - Padrões recorrentes devem ser priorizados\n   - Soluções obsoletas devem ser marcadas como tal\n</knowledge_management>\n\n<validation>\n- Todos os testes devem passar (verde)\n- Coverage mínimo: 80% em todas as métricas\n- Tempo de execução: < 5 segundos por arquivo\n- Zero warnings de TypeScript\n</validation>\n\n<thinking>\n1. Verificar e ler know-how.txt para aprender com experiências anteriores\n2. Entender o tipo de arquivo (componente, serviço, utilidade)\n3. Aplicar template apropriado baseado no tipo e conhecimento prévio\n4. Executar testes e identificar falhas específicas\n5. Adicionar mocks mínimos apenas onde necessário\n6. Documentar em know-how.txt cada solução bem-sucedida após falha\n7. Iterar até atingir 80%+ coverage sem falhas\n</thinking>\n\n<answer>\nArquivo de teste criado com estratégias de coverage rápido implementadas.\nExecute com: npm test src/domain/entities/mouse-action.ts.test.ts --coverage\n</answer>"
]