[
  {
    "path": "jest.config.js",
    "sha": "d5f921c3935de39ba3c71302b82313fc30b3b440",
    "size": 796,
    "summary": "Este arquivo configura o ambiente de testes para um projeto TypeScript utilizando Jest com suporte a módulos ECMAScript (ESM). Ele define presets específicos para integração com ts-jest, configura o ambiente de execução dos testes como Node.js, e mapeia extensões e módulos para garantir compatibilidade com importações ESM. Além disso, especifica padrões para localização dos testes, coleta e relatório de cobertura de código, e estabelece limites mínimos de cobertura para garantir qualidade. O arquivo também define timeout para execução dos testes e scripts de setup para inicialização do ambiente de testes, promovendo uma integração contínua e confiável no pipeline de desenvolvimento.",
    "content": "export default {\n  preset: 'ts-jest/presets/default-esm',\n  testEnvironment: 'node',\n  extensionsToTreatAsEsm: ['.ts'],\n  moduleNameMapper: {\n    '^(\\\\.{1,2}/.*)\\\\.js$': '$1',\n  },\n  transform: {\n    '^.+\\\\.ts$': [\n      'ts-jest',\n      {\n        useESM: true,\n      },\n    ],\n  },\n  testMatch: [\n    '**/__tests__/**/*.test.ts',\n    '**/tests/**/*.test.ts',\n    '**/tests/**/*.spec.ts',\n  ],\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/**/*.test.ts',\n    '!src/index.ts',\n  ],\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov', 'html'],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80,\n    },\n  },\n  testTimeout: 10000,\n  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],\n};",
    "processedAt": "2025-07-01T19:39:14.012Z"
  },
  {
    "path": "src/interface/schemas/automation.schemas.ts",
    "sha": "5ff159455b3e8f02c7aa84b3d44df7f6bab7773b",
    "size": 3020,
    "summary": "Este arquivo define múltiplos JSON Schemas para validação de objetos relacionados a interações de mouse e operações de captura e busca na tela, focando em ações como movimento, clique, arrasto e scroll do mouse, além de funcionalidades de reconhecimento e captura de regiões específicas da tela. Cada schema especifica propriedades detalhadas, tipos e restrições para garantir a integridade dos dados de entrada, como coordenadas, duração, suavidade e botões do mouse, além de parâmetros para reconhecimento visual com níveis de confiança e formatos de imagem. O comportamento central do código é fornecer uma estrutura rigorosa para validar comandos de automação de interface gráfica, assegurando que as operações sejam executadas com parâmetros corretos e dentro de limites definidos, facilitando a integração com sistemas de automação e testes visuais. A ausência de propriedades adicionais e a definição de valores padrão indicam um controle estrito sobre os dados, promovendo segurança e previsibilidade no uso das ações descritas. Este conjunto de schemas habilita a construção de fluxos automatizados confiáveis e parametrizáveis para manipulação de interfaces gráficas e análise visual, sendo essencial para sistemas que dependem de automação de UI e reconhecimento de padrões visuais.",
    "content": "export const mouseMoveJsonSchema = {\n  type: 'object',\n  properties: {\n    x: { type: 'integer', minimum: 0 },\n    y: { type: 'integer', minimum: 0 },\n    smooth: { type: 'boolean', default: true },\n    duration: { type: 'integer', minimum: 100, maximum: 5000, default: 1000 },\n  },\n  required: ['x', 'y'],\n  additionalProperties: false,\n};\n\nexport const mouseClickJsonSchema = {\n  type: 'object',\n  properties: {\n    x: { type: 'integer', minimum: 0 },\n    y: { type: 'integer', minimum: 0 },\n    button: { type: 'string', enum: ['left', 'right', 'middle'], default: 'left' },\n    doubleClick: { type: 'boolean', default: false },\n    smooth: { type: 'boolean', default: true },\n    duration: { type: 'integer', minimum: 100, maximum: 5000, default: 1000 },\n  },\n  additionalProperties: false,\n};\n\nexport const mouseDragJsonSchema = {\n  type: 'object',\n  properties: {\n    from: {\n      type: 'object',\n      properties: {\n        x: { type: 'integer', minimum: 0 },\n        y: { type: 'integer', minimum: 0 },\n      },\n      required: ['x', 'y'],\n      additionalProperties: false,\n    },\n    to: {\n      type: 'object',\n      properties: {\n        x: { type: 'integer', minimum: 0 },\n        y: { type: 'integer', minimum: 0 },\n      },\n      required: ['x', 'y'],\n      additionalProperties: false,\n    },\n    duration: { type: 'integer', minimum: 100, maximum: 5000, default: 1000 },\n    smooth: { type: 'boolean', default: true },\n  },\n  required: ['from', 'to'],\n  additionalProperties: false,\n};\n\nexport const mouseScrollJsonSchema = {\n  type: 'object',\n  properties: {\n    direction: { type: 'string', enum: ['up', 'down'] },\n    amount: { type: 'integer', minimum: 1, maximum: 10, default: 3 },\n    smooth: { type: 'boolean', default: true },\n    duration: { type: 'integer', minimum: 100, maximum: 5000, default: 1000 },\n  },\n  required: ['direction'],\n  additionalProperties: false,\n};\n\nexport const screenFindJsonSchema = {\n  type: 'object',\n  properties: {\n    template: { type: 'string', minLength: 1 },\n    confidence: { type: 'number', minimum: 0, maximum: 1, default: 0.8 },\n    region: {\n      type: 'object',\n      properties: {\n        x: { type: 'integer', minimum: 0 },\n        y: { type: 'integer', minimum: 0 },\n        width: { type: 'integer', minimum: 1 },\n        height: { type: 'integer', minimum: 1 },\n      },\n      required: ['x', 'y', 'width', 'height'],\n      additionalProperties: false,\n    },\n  },\n  required: ['template'],\n  additionalProperties: false,\n};\n\nexport const screenCaptureJsonSchema = {\n  type: 'object',\n  properties: {\n    region: {\n      type: 'object',\n      properties: {\n        x: { type: 'integer', minimum: 0 },\n        y: { type: 'integer', minimum: 0 },\n        width: { type: 'integer', minimum: 1 },\n        height: { type: 'integer', minimum: 1 },\n      },\n      required: ['x', 'y', 'width', 'height'],\n      additionalProperties: false,\n    },\n    format: { type: 'string', enum: ['png', 'jpg'], default: 'png' },\n  },\n  additionalProperties: false,\n};",
    "processedAt": "2025-07-01T19:39:19.734Z"
  },
  {
    "path": "src/application/dto/automation-request.dto.ts",
    "sha": "482c5a4be2ecd47ece881de6efab75cdf1921940",
    "size": 2252,
    "summary": "Este arquivo define schemas de validação para operações relacionadas ao controle e interação do mouse e captura de tela, utilizando a biblioteca Zod para garantir a integridade dos dados. Ele especifica formatos rigorosos para coordenadas, botões do mouse, durações e comportamentos opcionais como suavização (smooth) e confiança em reconhecimento de imagens, permitindo a construção de comandos robustos para automação de interface gráfica. Através desses schemas, o código habilita a validação e tipagem segura de requisições para movimentos, cliques, arrastes, scrolls e buscas visuais na tela, facilitando a integração com sistemas de automação e testes automatizados, garantindo consistência e previsibilidade no comportamento das interações simuladas.",
    "content": "import { z } from 'zod';\n\nexport const pointSchema = z.object({\n  x: z.number().int().min(0),\n  y: z.number().int().min(0),\n});\n\nexport const mouseMoveSchema = z.object({\n  x: z.number().int().min(0),\n  y: z.number().int().min(0),\n  smooth: z.boolean().optional().default(true),\n  duration: z.number().int().min(100).max(5000).optional().default(1000),\n});\n\nexport const mouseClickSchema = z.object({\n  x: z.number().int().min(0).optional(),\n  y: z.number().int().min(0).optional(),\n  button: z.enum(['left', 'right', 'middle']).optional().default('left'),\n  doubleClick: z.boolean().optional().default(false),\n  smooth: z.boolean().optional().default(true),\n  duration: z.number().int().min(100).max(5000).optional().default(1000),\n});\n\nexport const mouseDragSchema = z.object({\n  from: pointSchema,\n  to: pointSchema,\n  duration: z.number().int().min(100).max(5000).optional().default(1000),\n  smooth: z.boolean().optional().default(true),\n});\n\nexport const mouseScrollSchema = z.object({\n  direction: z.enum(['up', 'down']),\n  amount: z.number().int().min(1).max(10).default(3),\n  smooth: z.boolean().optional().default(true),\n  duration: z.number().int().min(100).max(5000).optional().default(1000),\n});\n\nexport const screenFindSchema = z.object({\n  template: z.string().min(1),\n  confidence: z.number().min(0).max(1).optional().default(0.8),\n  region: z\n    .object({\n      x: z.number().int().min(0),\n      y: z.number().int().min(0),\n      width: z.number().int().min(1),\n      height: z.number().int().min(1),\n    })\n    .optional(),\n});\n\nexport const screenCaptureSchema = z.object({\n  region: z\n    .object({\n      x: z.number().int().min(0),\n      y: z.number().int().min(0),\n      width: z.number().int().min(1),\n      height: z.number().int().min(1),\n    })\n    .optional(),\n  format: z.enum(['png', 'jpg']).optional().default('png'),\n});\n\nexport type MouseMoveRequest = z.infer<typeof mouseMoveSchema>;\nexport type MouseClickRequest = z.infer<typeof mouseClickSchema>;\nexport type MouseDragRequest = z.infer<typeof mouseDragSchema>;\nexport type MouseScrollRequest = z.infer<typeof mouseScrollSchema>;\nexport type ScreenFindRequest = z.infer<typeof screenFindSchema>;\nexport type ScreenCaptureRequest = z.infer<typeof screenCaptureSchema>;",
    "processedAt": "2025-07-01T19:39:26.997Z"
  },
  {
    "path": "src/config/mouse.config.ts",
    "sha": "590b008fc004a43927183332ecda73e3669def9a",
    "size": 934,
    "summary": "Este arquivo define uma configuração padrão para operações relacionadas ao mouse, centralizando parâmetros essenciais para controlar o comportamento de interações como duração, suavização e taxa de amostragem. Ele extrai valores de variáveis de ambiente para permitir flexibilidade e customização dinâmica, garantindo que as ações do mouse respeitem limites mínimos e máximos de duração, além de configurar parâmetros para streaming e interpolação suave. Essa configuração é fundamental para garantir uma experiência consistente e controlada em sistemas que dependem de manipulação precisa do mouse, facilitando a integração com outros módulos que realizam operações de input e automação.",
    "content": "/**\n * Configuração padrão para operações do mouse\n */\nexport const MouseDefaults = {\n  /** Duração mínima permitida para ações do mouse em ms */\n  minDuration: parseInt(process.env.MOUSE_MIN_DUR || '100', 10),\n  \n  /** Duração máxima permitida para ações do mouse em ms */\n  maxDuration: parseInt(process.env.MOUSE_MAX_DUR || '5000', 10),\n  \n  /** Valor padrão para movimento suave */\n  defaultSmooth: process.env.[REDACTED] === 'true' || false,\n  \n  /** Taxa de amostragem para interpolação suave (fps) */\n  sampleRate: parseInt(process.env.MOUSE_SAMPLE_RATE || '30', 10),\n  \n  /** Intervalo padrão em ms para streaming de posição */\n  streamInterval: parseInt(process.env.[REDACTED] || '100', 10),\n  \n  /** Duração padrão para movimentos em ms */\n  defaultDuration: parseInt(process.env.[REDACTED] || '1000', 10),\n} as const;\n\nexport type MouseConfig = typeof MouseDefaults;",
    "processedAt": "2025-07-01T19:39:27.123Z"
  },
  {
    "path": "src/infrastructure/adapters/nutjs/nutjs-mouse.adapter.ts",
    "sha": "a7a0aae6f8585936bbfbc362938f273a038b813a",
    "size": 3426,
    "summary": "Este arquivo implementa um adaptador de mouse utilizando a biblioteca Nut.js para abstrair operações de controle do mouse em um ambiente TypeScript. Ele oferece funcionalidades para movimentação do cursor com suporte a movimentos instantâneos e suaves via interpolação linear, cliques simples e duplos, arrasto de elementos, rolagem vertical e obtenção da posição atual do cursor. O componente integra-se ao sistema por meio da injeção de dependência, respeitando configurações globais de velocidade do mouse e mapeando botões de mouse do domínio para a biblioteca externa. Seu comportamento é orientado a garantir precisão e fluidez nas interações de mouse, habilitando automações e testes que dependem de manipulação programática do cursor e eventos de mouse em interfaces gráficas.",
    "content": "import { injectable } from 'tsyringe';\nimport { mouse, straightTo, Button } from '@nut-tree-fork/nut-js';\nimport { Point as NutPoint } from '@nut-tree-fork/nut-js';\nimport type { IMouseAdapter } from '../../../application/services/mouse.service.js';\nimport type { Point } from '../../../domain/entities/mouse-action.js';\nimport { MouseButton } from '../../../domain/entities/mouse-action.js';\nimport { environment } from '../../../config/environment.js';\nimport { MouseDefaults } from '../../../config/mouse.config.js';\n\n@injectable()\nexport class NutJSMouseAdapter implements IMouseAdapter {\n  private buttonMap: Record<MouseButton, Button> = {\n    [MouseButton.LEFT]: Button.LEFT,\n    [MouseButton.RIGHT]: Button.RIGHT,\n    [MouseButton.MIDDLE]: Button.MIDDLE,\n  };\n\n  constructor() {\n    mouse.config.mouseSpeed = environment.mouseSpeed;\n  }\n\n  async move(point: Point, smooth: boolean, duration: number): Promise<void> {\n    const targetPoint = new NutPoint(point.x, point.y);\n    \n    if (!smooth) {\n      // Movimento instantâneo\n      mouse.config.mouseSpeed = 10000;\n      await mouse.move(straightTo(targetPoint));\n      return;\n    }\n\n    // Movimento suave com interpolação linear\n    const currentPos = await mouse.getPosition();\n    const startX = currentPos.x;\n    const startY = currentPos.y;\n    const deltaX = point.x - startX;\n    const deltaY = point.y - startY;\n    \n    // Calcular número de passos baseado na taxa de amostragem\n    const steps = Math.max(1, Math.floor(duration * MouseDefaults.sampleRate / 1000));\n    const stepDuration = duration / steps;\n    \n    // Executar interpolação linear\n    for (let i = 1; i <= steps; i++) {\n      const progress = i / steps;\n      const intermediateX = Math.round(startX + deltaX * progress);\n      const intermediateY = Math.round(startY + deltaY * progress);\n      \n      const intermediatePoint = new NutPoint(intermediateX, intermediateY);\n      mouse.config.mouseSpeed = 10000; // Movimento instantâneo para cada step\n      await mouse.move(straightTo(intermediatePoint));\n      \n      // Aguardar antes do próximo passo (exceto no último)\n      if (i < steps) {\n        await this.delay(stepDuration);\n      }\n    }\n  }\n\n  /**\n   * Aguarda um período em milissegundos\n   * @param ms - Tempo de espera em milissegundos\n   */\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  async click(button: MouseButton, doubleClick: boolean): Promise<void> {\n    const nutButton = this.buttonMap[button];\n\n    if (doubleClick) {\n      await mouse.doubleClick(nutButton);\n    } else {\n      await mouse.click(nutButton);\n    }\n  }\n\n  async clickAt(point: Point, button: MouseButton, doubleClick: boolean): Promise<void> {\n    await this.move(point, true, 500);\n    await this.click(button, doubleClick);\n  }\n\n  async drag(from: Point, to: Point, duration: number): Promise<void> {\n    await this.move(from, true, duration / 3);\n    await mouse.pressButton(Button.LEFT);\n    await this.move(to, true, (duration * 2) / 3);\n    await mouse.releaseButton(Button.LEFT);\n  }\n\n  async scroll(direction: 'up' | 'down', amount: number): Promise<void> {\n    const scrollAmount = direction === 'up' ? -amount : amount;\n    await mouse.scrollDown(scrollAmount);\n  }\n\n  async getPosition(): Promise<Point> {\n    const position = await mouse.getPosition();\n    return { x: position.x, y: position.y };\n  }\n}",
    "processedAt": "2025-07-01T19:39:28.892Z"
  },
  {
    "path": "src/application/services/mouse.service.ts",
    "sha": "a4c885a3ded4e1706068560f2081dd20d11d663d",
    "size": 4871,
    "summary": "O código implementa um serviço de controle de mouse que abstrai operações comuns como mover, clicar, arrastar e rolar o cursor na tela, garantindo validação de coordenadas e tratamento de erros. Utiliza injeção de dependência para desacoplar a implementação do adaptador de mouse, permitindo flexibilidade e testabilidade. O serviço também incorpora logging detalhado para monitoramento das ações, além de suportar movimentos suaves e parametrizados, proporcionando uma interface robusta para automação de interações com o mouse em aplicações que demandam controle programático preciso.",
    "content": "import { injectable, inject } from 'tsyringe';\nimport type {\n  MouseMoveRequest,\n  MouseClickRequest,\n  MouseDragRequest,\n  MouseScrollRequest,\n} from '../dto/automation-request.dto.js';\nimport type { Point } from '../../domain/entities/mouse-action.js';\nimport { MouseButton } from '../../domain/entities/mouse-action.js';\nimport { screen } from '@nut-tree-fork/nut-js';\nimport pino from 'pino';\n\nexport interface IMouseAdapter {\n  move(point: Point, smooth: boolean, duration: number): Promise<void>;\n  click(button: MouseButton, doubleClick: boolean): Promise<void>;\n  clickAt(point: Point, button: MouseButton, doubleClick: boolean): Promise<void>;\n  drag(from: Point, to: Point, duration: number): Promise<void>;\n  scroll(direction: 'up' | 'down', amount: number): Promise<void>;\n  getPosition(): Promise<Point>;\n}\n\n@injectable()\nexport class MouseService {\n  private readonly logger = pino({ name: 'MouseService' });\n\n  constructor(\n    @inject('MouseAdapter')\n    private readonly mouseAdapter: IMouseAdapter,\n  ) {}\n\n  async move(request: MouseMoveRequest): Promise<void> {\n    const { x, y, smooth = true, duration = 1000 } = request;\n    \n    // Validar coordenadas\n    await this.validateCoordinates(x, y);\n    \n    this.logger.debug({ x, y, smooth, duration }, 'Moving mouse');\n    \n    try {\n      await this.mouseAdapter.move({ x, y }, smooth, duration);\n      this.logger.info({ x, y }, 'Mouse moved successfully');\n    } catch (error) {\n      this.logger.error({ error, x, y }, 'Failed to move mouse');\n      throw error;\n    }\n  }\n\n  async click(request: MouseClickRequest): Promise<void> {\n    const { x, y, button = MouseButton.LEFT, doubleClick = false, smooth = true, duration = 1000 } = request;\n\n    if (x !== undefined && y !== undefined) {\n      // Validar coordenadas antes de clicar\n      await this.validateCoordinates(x, y);\n      \n      // Se smooth é true, mover primeiro com a duração especificada\n      if (smooth) {\n        await this.mouseAdapter.move({ x, y }, smooth, duration);\n      }\n      \n      await this.mouseAdapter.clickAt({ x, y }, button as MouseButton, doubleClick);\n      this.logger.info({ x, y, button, doubleClick }, 'Mouse clicked successfully');\n    } else {\n      await this.mouseAdapter.click(button as MouseButton, doubleClick);\n      this.logger.info({ button, doubleClick }, 'Mouse clicked at current position');\n    }\n  }\n\n  async drag(request: MouseDragRequest): Promise<void> {\n    const { from, to, duration = 1000, smooth = true } = request;\n    \n    // Validar coordenadas de origem e destino\n    await this.validateCoordinates(from.x, from.y);\n    await this.validateCoordinates(to.x, to.y);\n    \n    this.logger.debug({ from, to, duration, smooth }, 'Dragging mouse');\n    \n    try {\n      // Se smooth é true, mover primeiro para a posição inicial com movimento suave\n      if (smooth) {\n        await this.mouseAdapter.move(from, smooth, duration / 3);\n      }\n      \n      await this.mouseAdapter.drag(from, to, duration);\n      this.logger.info({ from, to }, 'Mouse dragged successfully');\n    } catch (error) {\n      this.logger.error({ error, from, to }, 'Failed to drag mouse');\n      throw error;\n    }\n  }\n\n  async scroll(request: MouseScrollRequest): Promise<void> {\n    const { direction, amount = 3, smooth = true, duration = 1000 } = request;\n    \n    this.logger.debug({ direction, amount, smooth, duration }, 'Scrolling mouse');\n    \n    try {\n      if (smooth && duration > 0) {\n        // Dividir o scroll em múltiplos passos menores para criar efeito suave\n        const steps = Math.max(1, Math.floor(duration * 30 / 1000)); // 30 fps\n        const stepAmount = amount / steps;\n        const stepDuration = duration / steps;\n        \n        for (let i = 0; i < steps; i++) {\n          await this.mouseAdapter.scroll(direction, stepAmount);\n          if (i < steps - 1) {\n            await new Promise(resolve => setTimeout(resolve, stepDuration));\n          }\n        }\n      } else {\n        // Scroll instantâneo\n        await this.mouseAdapter.scroll(direction, amount);\n      }\n      \n      this.logger.info({ direction, amount }, 'Mouse scrolled successfully');\n    } catch (error) {\n      this.logger.error({ error, direction, amount }, 'Failed to scroll mouse');\n      throw error;\n    }\n  }\n\n  async getPosition(): Promise<Point> {\n    return this.mouseAdapter.getPosition();\n  }\n\n  private async validateCoordinates(x: number, y: number): Promise<void> {\n    // Obter dimensões da tela\n    const screenWidth = await screen.width();\n    const screenHeight = await screen.height();\n\n    if (x < 0 || x >= screenWidth) {\n      throw new Error(`Invalid X coordinate: ${x}. Must be between 0 and ${screenWidth - 1}`);\n    }\n\n    if (y < 0 || y >= screenHeight) {\n      throw new Error(`Invalid Y coordinate: ${y}. Must be between 0 and ${screenHeight - 1}`);\n    }\n  }\n}",
    "processedAt": "2025-07-01T19:39:29.765Z"
  },
  {
    "path": "src/config/environment.ts",
    "sha": "d210c4edf611b654d1136b562dfc1cce533930e1",
    "size": 590,
    "summary": "Este arquivo de configuração em TypeScript tem como objetivo principal centralizar e padronizar a leitura das variáveis de ambiente essenciais para a aplicação, garantindo que parâmetros críticos como NODE_ENV, PORT, HOST, LOG_LEVEL, entre outros, estejam disponíveis de forma tipada e segura. Ele utiliza a biblioteca dotenv para carregar variáveis do ambiente, aplicando valores padrão quando não definidos, o que assegura robustez e previsibilidade no comportamento da aplicação em diferentes ambientes (desenvolvimento, produção). Além disso, expõe flags booleanas para facilitar a identificação do ambiente atual, suportando decisões condicionais em runtime. Essa abordagem modular e declarativa contribui para a manutenção, escalabilidade e integração com outros módulos do sistema, promovendo um padrão consistente para configuração e controle de comportamento da aplicação.",
    "content": "import { config } from 'dotenv';\n\nconfig();\n\nexport const environment = {\n  nodeEnv: process.env.NODE_ENV || 'development',\n  port: parseInt(process.env.PORT || '3000', 10),\n  host: process.env.HOST || '0.0.0.0',\n  logLevel: process.env.LOG_LEVEL || 'info',\n  mouseSpeed: parseInt(process.env.MOUSE_SPEED || '500', 10),\n  screenConfidence: parseFloat(process.env.SCREEN_CONFIDENCE || '0.8'),\n  apiKey: process.env.API_KEY || 'default-api-key',\n} as const;\n\nexport const isDevelopment = environment.nodeEnv === 'development';\nexport const isProduction = environment.nodeEnv === 'production';",
    "processedAt": "2025-07-01T19:39:31.188Z"
  },
  {
    "path": "tests/setup.ts",
    "sha": "f7e417fd9313b9de02cfe9655e3627f6de02831e",
    "size": 1022,
    "summary": "Este arquivo configura o ambiente global para execução de testes automatizados em um projeto Node.js utilizando Jest. Ele define variáveis de ambiente específicas para o contexto de testes, como chaves de API e parâmetros relacionados à captura de eventos de mouse, garantindo que o ambiente de teste seja isolado e controlado. Além disso, implementa um mock global para o logger pino, evitando a emissão de logs durante os testes e configurando um timeout padrão para testes assíncronos, o que assegura estabilidade e previsibilidade na execução dos testes. O arquivo também prepara hooks globais para setup e teardown, facilitando a manutenção e extensão das configurações de teste. Essa configuração é essencial para garantir a confiabilidade, performance e isolamento dos testes automatizados no ciclo de desenvolvimento do software.",
    "content": "/**\n * Configuração global para os testes\n */\nimport 'reflect-metadata';\n\n// Configurar variáveis de ambiente para testes\nprocess.env.NODE_ENV = 'test';\nprocess.env.API_KEY = 'test-api-key';\nprocess.env.MOUSE_MIN_DUR = '100';\nprocess.env.MOUSE_MAX_DUR = '5000';\nprocess.env.MOUSE_SAMPLE_RATE = '30';\nprocess.env.[REDACTED] = '100';\n\n// Mock global do pino logger para evitar logs durante testes\njest.mock('pino', () => {\n  return jest.fn(() => ({\n    info: jest.fn(),\n    error: jest.fn(),\n    debug: jest.fn(),\n    warn: jest.fn(),\n    fatal: jest.fn(),\n    trace: jest.fn(),\n    child: jest.fn(() => ({\n      info: jest.fn(),\n      error: jest.fn(),\n      debug: jest.fn(),\n      warn: jest.fn(),\n      fatal: jest.fn(),\n      trace: jest.fn(),\n    })),\n  }));\n});\n\n// Configuração global do Jest\nbeforeAll(() => {\n  // Configurações globais antes de todos os testes\n});\n\nafterAll(() => {\n  // Limpeza global após todos os testes\n});\n\n// Timeout global para testes assíncronos\njest.setTimeout(10000);",
    "processedAt": "2025-07-01T19:39:35.055Z"
  },
  {
    "path": "tests/unit/services/mouse.service.test.ts",
    "sha": "1da49b8c2533f438526fecba3d05ccb72b2d3467",
    "size": 6366,
    "summary": "Este arquivo contém testes unitários para o MouseService, focando em validar funcionalidades relacionadas ao controle do mouse, como movimentos suaves (smooth), duração (duration), cliques, arrastos (drag), scroll e obtenção da posição atual. O código assegura que as operações respeitam limites de coordenadas da tela, que os métodos do adapter são chamados corretamente com parâmetros esperados e que comportamentos condicionais, como movimentação prévia antes do clique ou divisão do scroll em múltiplos passos, funcionam conforme especificado. Através de mocks e simulações de tempo, o teste garante robustez e confiabilidade das interações do serviço com o hardware virtualizado, promovendo uma interface consistente para manipulação do mouse em um ambiente controlado e testável.",
    "content": "/**\n * Testes unitários para MouseService\n * Foco nas novas funcionalidades de smooth e duration\n */\nimport 'reflect-metadata';\nimport { MouseService, type IMouseAdapter } from '../../../src/application/services/mouse.service.js';\nimport { MouseButton } from '../../../src/domain/entities/mouse-action.js';\nimport type { Point } from '../../../src/domain/entities/mouse-action.js';\nimport { screen } from '@nut-tree-fork/nut-js';\n\n// Mock do screen\njest.mock('@nut-tree-fork/nut-js', () => ({\n  screen: {\n    width: jest.fn().mockResolvedValue(1920),\n    height: jest.fn().mockResolvedValue(1080),\n  },\n}));\n\ndescribe('MouseService', () => {\n  let mouseService: MouseService;\n  let mockMouseAdapter: jest.Mocked<IMouseAdapter>;\n\n  beforeEach(() => {\n    // Criar mock do adapter\n    mockMouseAdapter = {\n      move: jest.fn().mockResolvedValue(undefined),\n      click: jest.fn().mockResolvedValue(undefined),\n      clickAt: jest.fn().mockResolvedValue(undefined),\n      drag: jest.fn().mockResolvedValue(undefined),\n      scroll: jest.fn().mockResolvedValue(undefined),\n      getPosition: jest.fn().mockResolvedValue({ x: 100, y: 100 }),\n    };\n\n    // Injetar mock no serviço\n    mouseService = new MouseService(mockMouseAdapter);\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('move', () => {\n    it('deve chamar o adapter com parâmetros corretos para movimento suave', async () => {\n      const request = { x: 500, y: 500, smooth: true, duration: 2000 };\n      \n      await mouseService.move(request);\n\n      expect(mockMouseAdapter.move).toHaveBeenCalledWith(\n        { x: 500, y: 500 },\n        true,\n        2000\n      );\n    });\n\n    it('deve usar valores padrão quando smooth e duration não forem fornecidos', async () => {\n      const request = { x: 500, y: 500 };\n      \n      await mouseService.move(request);\n\n      expect(mockMouseAdapter.move).toHaveBeenCalledWith(\n        { x: 500, y: 500 },\n        true, // padrão\n        1000  // padrão\n      );\n    });\n\n    it('deve validar coordenadas antes de mover', async () => {\n      const request = { x: 2000, y: 500 }; // x fora da tela\n      \n      await expect(mouseService.move(request)).rejects.toThrow(\n        'Invalid X coordinate: 2000. Must be between 0 and 1919'\n      );\n      \n      expect(mockMouseAdapter.move).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('click', () => {\n    it('deve mover antes de clicar quando smooth for true', async () => {\n      const request = { x: 300, y: 400, smooth: true, duration: 500 };\n      \n      await mouseService.click(request);\n\n      // Verificar que moveu primeiro\n      expect(mockMouseAdapter.move).toHaveBeenCalledWith(\n        { x: 300, y: 400 },\n        true,\n        500\n      );\n      \n      // Verificar que clicou depois\n      expect(mockMouseAdapter.clickAt).toHaveBeenCalledWith(\n        { x: 300, y: 400 },\n        MouseButton.LEFT,\n        false\n      );\n    });\n\n    it('não deve mover quando smooth for false', async () => {\n      const request = { x: 300, y: 400, smooth: false };\n      \n      await mouseService.click(request);\n\n      expect(mockMouseAdapter.move).not.toHaveBeenCalled();\n      expect(mockMouseAdapter.clickAt).toHaveBeenCalledWith(\n        { x: 300, y: 400 },\n        MouseButton.LEFT,\n        false\n      );\n    });\n\n    it('deve clicar na posição atual quando coordenadas não forem fornecidas', async () => {\n      const request = { button: 'right' as any, doubleClick: true };\n      \n      await mouseService.click(request);\n\n      expect(mockMouseAdapter.click).toHaveBeenCalledWith(\n        MouseButton.RIGHT,\n        true\n      );\n      expect(mockMouseAdapter.clickAt).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('drag', () => {\n    it('deve mover para posição inicial antes de arrastar quando smooth for true', async () => {\n      const request = {\n        from: { x: 100, y: 100 },\n        to: { x: 500, y: 500 },\n        smooth: true,\n        duration: 1500,\n      };\n      \n      await mouseService.drag(request);\n\n      // Verificar movimento inicial\n      expect(mockMouseAdapter.move).toHaveBeenCalledWith(\n        { x: 100, y: 100 },\n        true,\n        500 // duration / 3\n      );\n      \n      // Verificar arrasto\n      expect(mockMouseAdapter.drag).toHaveBeenCalledWith(\n        { x: 100, y: 100 },\n        { x: 500, y: 500 },\n        1500\n      );\n    });\n\n    it('deve validar coordenadas de origem e destino', async () => {\n      const request = {\n        from: { x: 100, y: 100 },\n        to: { x: 2000, y: 500 }, // x fora da tela\n      };\n      \n      await expect(mouseService.drag(request)).rejects.toThrow(\n        'Invalid X coordinate: 2000. Must be between 0 and 1919'\n      );\n    });\n  });\n\n  describe('scroll', () => {\n    beforeEach(() => {\n      jest.useFakeTimers();\n    });\n\n    afterEach(() => {\n      jest.useRealTimers();\n    });\n\n    it('deve dividir scroll em múltiplos passos quando smooth for true', async () => {\n      const request = {\n        direction: 'down' as const,\n        amount: 6,\n        smooth: true,\n        duration: 1000,\n      };\n      \n      const scrollPromise = mouseService.scroll(request);\n      \n      // Avançar o tempo para permitir execução\n      await jest.runAllTimersAsync();\n      await scrollPromise;\n\n      // Com 30 fps e 1000ms, deve ter 30 chamadas\n      const expectedCalls = Math.floor(1000 * 30 / 1000);\n      expect(mockMouseAdapter.scroll).toHaveBeenCalledTimes(expectedCalls);\n      \n      // Cada chamada deve ter uma fração do amount total\n      const expectedStepAmount = 6 / expectedCalls;\n      expect(mockMouseAdapter.scroll).toHaveBeenCalledWith('down', expectedStepAmount);\n    });\n\n    it('deve fazer scroll instantâneo quando smooth for false', async () => {\n      const request = {\n        direction: 'up' as const,\n        amount: 5,\n        smooth: false,\n      };\n      \n      await mouseService.scroll(request);\n\n      expect(mockMouseAdapter.scroll).toHaveBeenCalledTimes(1);\n      expect(mockMouseAdapter.scroll).toHaveBeenCalledWith('up', 5);\n    });\n  });\n\n  describe('getPosition', () => {\n    it('deve retornar a posição atual do mouse', async () => {\n      const position = await mouseService.getPosition();\n      \n      expect(position).toEqual({ x: 100, y: 100 });\n      expect(mockMouseAdapter.getPosition).toHaveBeenCalled();\n    });\n  });\n});",
    "processedAt": "2025-07-01T19:39:51.472Z"
  },
  {
    "path": "package.json",
    "sha": "caef2d48c9dbe4247ecbe7ebe800f7df5a270cc5",
    "size": 1584,
    "summary": "O projeto nutjs-rest-api é uma API RESTful que serve como um wrapper para a automação desktop utilizando a biblioteca NutJS. Seu comportamento central consiste em expor funcionalidades de automação de interface gráfica via endpoints HTTP, permitindo que clientes controlem operações de desktop remotamente. A aplicação gerencia o ciclo de vida das requisições, valida dados de entrada com schemas, e integra-se com serviços de logging e injeção de dependências para garantir modularidade e rastreabilidade. A arquitetura modular e o uso de Fastify como framework web proporcionam alta performance e escalabilidade, enquanto o uso de TypeScript e ferramentas de linting e testes asseguram qualidade e manutenção do código. O projeto está estruturado para suportar desenvolvimento ágil, testes unitários e integração contínua, facilitando a entrega de automações confiáveis e seguras para usuários finais.",
    "content": "{\n  \"name\": \"nutjs-rest-api\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"description\": \"REST API wrapper for NutJS desktop automation\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"dev\": \"tsx watch src/index.ts\",\n    \"build\": \"tsc -p tsconfig.json\",\n    \"build:prod\": \"tsc -p tsconfig.prod.json\",\n    \"start\": \"node dist/index.js\",\n    \"test\": \"jest\",\n    \"test:unit\": \"jest tests/unit\",\n    \"test:integration\": \"jest tests/integration\",\n    \"test:coverage\": \"jest --coverage\",\n    \"test:api\": \"tsx src/test-endpoint.ts\",\n    \"lint\": \"eslint src/**/*.ts\",\n    \"lint:fix\": \"eslint src/**/*.ts --fix\",\n    \"format\": \"prettier --write src/**/*.ts\",\n    \"format:check\": \"prettier --check src/**/*.ts\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"audit:roadmap\": \"echo 'TODO: Implement roadmap audit script'\",\n    \"clean\": \"rm -rf dist coverage .nyc_output\"\n  },\n  \"dependencies\": {\n    \"@nut-tree-fork/nut-js\": \"^4.2.0\",\n    \"fastify\": \"^4.24.0\",\n    \"zod\": \"^3.22.4\",\n    \"pino\": \"^8.16.0\",\n    \"tsyringe\": \"^4.8.0\",\n    \"reflect-metadata\": \"^0.2.1\",\n    \"dotenv\": \"^16.3.1\",\n    \"pino-pretty\": \"^10.3.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.10.0\",\n    \"typescript\": \"^5.3.2\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.12.0\",\n    \"@typescript-eslint/parser\": \"^6.12.0\",\n    \"eslint\": \"^8.54.0\",\n    \"eslint-config-prettier\": \"^9.0.0\",\n    \"eslint-plugin-prettier\": \"^5.0.1\",\n    \"prettier\": \"^3.1.0\",\n    \"tsx\": \"^4.6.0\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.1.1\",\n    \"@types/jest\": \"^29.5.11\",\n    \"eventsource\": \"^2.0.2\",\n    \"@types/eventsource\": \"^1.1.15\"\n  }\n}",
    "processedAt": "2025-07-01T19:40:14.560Z"
  },
  {
    "path": "src/interface/controllers/automation.controller.ts",
    "sha": "f11f8d0e00938806466bcb94bdb9e2dcc4e7be89",
    "size": 9089,
    "summary": "O arquivo define a classe AutomationController, responsável por expor uma API RESTful para controle e automação de interações com o mouse e a tela do sistema operacional. Ele implementa endpoints para movimentação, clique, arrasto e scroll do mouse, além de captura e busca de imagens na tela, utilizando serviços especializados para abstrair a lógica de automação. Um destaque funcional é o endpoint de streaming via Server-Sent Events que transmite continuamente a posição do mouse, com autenticação simples por API key. O controlador integra validações de schemas JSON para garantir a conformidade dos dados recebidos e produz respostas padronizadas, facilitando a integração com clientes externos. A arquitetura segue princípios de injeção de dependência e separação clara entre controller e serviços, promovendo manutenibilidade e escalabilidade do sistema.",
    "content": "import type { FastifyInstance, FastifyReply, FastifyRequest } from 'fastify';\nimport { container } from 'tsyringe';\nimport { MouseService } from '../../application/services/mouse.service.js';\nimport { ScreenService } from '../../application/services/screen.service.js';\nimport {\n  mouseMoveJsonSchema,\n  mouseClickJsonSchema,\n  mouseDragJsonSchema,\n  mouseScrollJsonSchema,\n  screenFindJsonSchema,\n  screenCaptureJsonSchema,\n} from '../schemas/automation.schemas.js';\nimport type {\n  MouseMoveRequest,\n  MouseClickRequest,\n  MouseDragRequest,\n  MouseScrollRequest,\n  ScreenFindRequest,\n  ScreenCaptureRequest,\n} from '../../application/dto/automation-request.dto.js';\nimport { MouseDefaults } from '../../config/mouse.config.js';\nimport { environment } from '../../config/environment.js';\nimport pino from 'pino';\n\nexport class AutomationController {\n  private mouseService: MouseService;\n  private screenService: ScreenService;\n  private readonly logger = pino({ name: 'AutomationController' });\n\n  constructor() {\n    this.mouseService = container.resolve<MouseService>('MouseService');\n    this.screenService = container.resolve<ScreenService>('ScreenService');\n  }\n\n  registerRoutes(server: FastifyInstance): void {\n    server.post(\n      '/mouse/move',\n      {\n        schema: {\n          body: mouseMoveJsonSchema,\n          response: {\n            200: {\n              type: 'object',\n              properties: {\n                success: { type: 'boolean' },\n              },\n            },\n          },\n        },\n      },\n      this.mouseMove.bind(this),\n    );\n\n    server.post(\n      '/mouse/click',\n      {\n        schema: {\n          body: mouseClickJsonSchema,\n          response: {\n            200: {\n              type: 'object',\n              properties: {\n                success: { type: 'boolean' },\n              },\n            },\n          },\n        },\n      },\n      this.mouseClick.bind(this),\n    );\n\n    server.post(\n      '/mouse/drag',\n      {\n        schema: {\n          body: mouseDragJsonSchema,\n          response: {\n            200: {\n              type: 'object',\n              properties: {\n                success: { type: 'boolean' },\n              },\n            },\n          },\n        },\n      },\n      this.mouseDrag.bind(this),\n    );\n\n    server.post(\n      '/mouse/scroll',\n      {\n        schema: {\n          body: mouseScrollJsonSchema,\n          response: {\n            200: {\n              type: 'object',\n              properties: {\n                success: { type: 'boolean' },\n              },\n            },\n          },\n        },\n      },\n      this.mouseScroll.bind(this),\n    );\n\n    server.get(\n      '/mouse/position',\n      {\n        schema: {\n          response: {\n            200: {\n              type: 'object',\n              properties: {\n                success: { type: 'boolean' },\n                data: {\n                  type: 'object',\n                  properties: {\n                    x: { type: 'number' },\n                    y: { type: 'number' },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      this.mousePosition.bind(this),\n    );\n\n    server.get(\n      '/mouse/position/stream',\n      {\n        schema: {\n          headers: {\n            type: 'object',\n            properties: {\n              'x-api-key': { type: 'string' },\n            },\n          },\n        },\n      },\n      this.mousePositionStream.bind(this),\n    );\n\n    server.post(\n      '/screen/find',\n      {\n        schema: {\n          body: screenFindJsonSchema,\n          response: {\n            200: {\n              type: 'object',\n              properties: {\n                success: { type: 'boolean' },\n                data: {\n                  type: 'object',\n                  properties: {\n                    matches: {\n                      type: 'array',\n                      items: {\n                        type: 'object',\n                        properties: {\n                          x: { type: 'number' },\n                          y: { type: 'number' },\n                          width: { type: 'number' },\n                          height: { type: 'number' },\n                          confidence: { type: 'number' },\n                        },\n                      },\n                    },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      this.screenFind.bind(this),\n    );\n\n    server.post(\n      '/screen/capture',\n      {\n        schema: {\n          body: screenCaptureJsonSchema,\n          response: {\n            200: {\n              type: 'object',\n              properties: {\n                success: { type: 'boolean' },\n                data: {\n                  type: 'object',\n                  properties: {\n                    image: { type: 'string' },\n                  },\n                },\n              },\n            },\n          },\n        },\n      },\n      this.screenCapture.bind(this),\n    );\n  }\n\n  private async mouseMove(\n    request: FastifyRequest<{ Body: MouseMoveRequest }>,\n    reply: FastifyReply,\n  ): Promise<void> {\n    await this.mouseService.move(request.body);\n    await reply.send({ success: true });\n  }\n\n  private async mouseClick(\n    request: FastifyRequest<{ Body: MouseClickRequest }>,\n    reply: FastifyReply,\n  ): Promise<void> {\n    await this.mouseService.click(request.body);\n    await reply.send({ success: true });\n  }\n\n  private async mouseDrag(\n    request: FastifyRequest<{ Body: MouseDragRequest }>,\n    reply: FastifyReply,\n  ): Promise<void> {\n    await this.mouseService.drag(request.body);\n    await reply.send({ success: true });\n  }\n\n  private async mouseScroll(\n    request: FastifyRequest<{ Body: MouseScrollRequest }>,\n    reply: FastifyReply,\n  ): Promise<void> {\n    await this.mouseService.scroll(request.body);\n    await reply.send({ success: true });\n  }\n\n  private async mousePosition(request: FastifyRequest, reply: FastifyReply): Promise<void> {\n    const position = await this.mouseService.getPosition();\n    await reply.send({ success: true, data: position });\n  }\n\n  private async screenFind(\n    request: FastifyRequest<{ Body: ScreenFindRequest }>,\n    reply: FastifyReply,\n  ): Promise<void> {\n    const matches = await this.screenService.findTemplate(request.body);\n    await reply.send({ success: true, data: { matches } });\n  }\n\n  private async screenCapture(\n    request: FastifyRequest<{ Body: ScreenCaptureRequest }>,\n    reply: FastifyReply,\n  ): Promise<void> {\n    const image = await this.screenService.capture(request.body);\n    await reply.send({ success: true, data: { image } });\n  }\n\n  /**\n   * Endpoint de streaming para posição contínua do mouse usando Server-Sent Events\n   * @param request - Requisição Fastify\n   * @param reply - Resposta Fastify\n   */\n  private async mousePositionStream(\n    request: FastifyRequest<{ Headers: { 'x-api-key'?: string } }>,\n    reply: FastifyReply,\n  ): Promise<void> {\n    // Validação simples de API key (pode ser melhorada com um sistema real de autenticação)\n    const apiKey = request.headers['x-api-key'];\n    if (!apiKey || apiKey !== environment.apiKey) {\n      await reply.code(401).send({ success: false, error: 'Unauthorized' });\n      return;\n    }\n\n    // Configurar headers para Server-Sent Events\n    reply.raw.writeHead(200, {\n      'Content-Type': 'text/event-stream',\n      'Cache-Control': 'no-cache',\n      'Connection': 'keep-alive',\n      'Content-Security-Policy': \"default-src 'none'\",\n      'X-Content-Type-Options': 'nosniff',\n    });\n\n    this.logger.info('Starting mouse position stream');\n\n    let intervalId: NodeJS.Timeout;\n    let messageCount = 0;\n\n    // Função para enviar posição do mouse\n    const sendMousePosition = async () => {\n      try {\n        const position = await this.mouseService.getPosition();\n        const data = {\n          x: position.x,\n          y: position.y,\n          timestamp: Date.now(),\n        };\n\n        // Enviar dados no formato SSE\n        reply.raw.write(`data: ${JSON.stringify(data)}\\n\\n`);\n\n        // Log apenas 1 em cada 10 mensagens para evitar spam\n        messageCount++;\n        if (messageCount % 10 === 0) {\n          this.logger.debug({ position, messageCount }, 'Sent mouse position');\n        }\n      } catch (error) {\n        this.logger.error({ error }, 'Error getting mouse position');\n        clearInterval(intervalId);\n        reply.raw.end();\n      }\n    };\n\n    // Iniciar streaming com intervalo configurável\n    intervalId = setInterval(sendMousePosition, MouseDefaults.streamInterval);\n\n    // Enviar primeira posição imediatamente\n    await sendMousePosition();\n\n    // Limpar recursos quando a conexão for fechada\n    request.raw.on('close', () => {\n      this.logger.info({ messageCount }, 'Mouse position stream closed');\n      clearInterval(intervalId);\n    });\n\n    // Tratar erros de conexão\n    request.raw.on('error', (error) => {\n      this.logger.error({ error }, 'Stream connection error');\n      clearInterval(intervalId);\n    });\n  }\n}",
    "processedAt": "2025-07-01T19:40:19.691Z"
  },
  {
    "path": "tests/integration/mouse-stream.test.ts",
    "sha": "9bfc51c8f406bb6bf0c19b7d2c5565d6565c8fb7",
    "size": 6471,
    "summary": "Este arquivo contém testes de integração para o endpoint de streaming da posição do mouse, implementado em um servidor Fastify com injeção de dependências via tsyringe. O foco principal é validar o comportamento do endpoint /mouse/position/stream, garantindo autenticação via API key, transmissão contínua e ordenada de eventos de posição do mouse, além de assegurar que o streaming pare corretamente ao fechar a conexão. Os testes simulam um adapter de mouse mockado para controlar as posições retornadas, verificam respostas HTTP para cenários de autenticação e monitoram a performance do streaming, assegurando que múltiplos eventos são enviados em tempo real. A abordagem garante robustez na integração do serviço de mouse com o controlador de automação, validando tanto regras de negócio quanto aspectos de performance e segurança.",
    "content": "/**\n * Testes de integração para o endpoint de streaming de posição do mouse\n */\nimport 'reflect-metadata';\nimport Fastify, { FastifyInstance } from 'fastify';\nimport { container } from 'tsyringe';\nimport { AutomationController } from '../../src/interface/controllers/automation.controller.js';\nimport { MouseService, type IMouseAdapter } from '../../src/application/services/mouse.service.js';\nimport { environment } from '../../src/config/environment.js';\nimport EventSource from 'eventsource';\n\ndescribe('Mouse Position Stream Endpoint', () => {\n  let app: FastifyInstance;\n  let mockMouseAdapter: jest.Mocked<IMouseAdapter>;\n  let eventSource: EventSource;\n  const testPort = 3001;\n  const baseUrl = `http://localhost:${testPort}`;\n\n  beforeAll(async () => {\n    // Criar mock do adapter\n    mockMouseAdapter = {\n      move: jest.fn().mockResolvedValue(undefined),\n      click: jest.fn().mockResolvedValue(undefined),\n      clickAt: jest.fn().mockResolvedValue(undefined),\n      drag: jest.fn().mockResolvedValue(undefined),\n      scroll: jest.fn().mockResolvedValue(undefined),\n      getPosition: jest.fn()\n        .mockResolvedValueOnce({ x: 100, y: 100 })\n        .mockResolvedValueOnce({ x: 150, y: 150 })\n        .mockResolvedValueOnce({ x: 200, y: 200 })\n        .mockResolvedValueOnce({ x: 250, y: 250 })\n        .mockResolvedValueOnce({ x: 300, y: 300 })\n        .mockResolvedValue({ x: 350, y: 350 }),\n    };\n\n    // Registrar mocks no container\n    container.register('MouseAdapter', { useValue: mockMouseAdapter });\n    container.register('MouseService', { useClass: MouseService });\n\n    // Criar instância do Fastify\n    app = Fastify({ logger: false });\n    \n    // Registrar rotas\n    const controller = new AutomationController();\n    controller.registerRoutes(app);\n\n    // Iniciar servidor\n    await app.listen({ port: testPort });\n  });\n\n  afterAll(async () => {\n    await app.close();\n    container.clearInstances();\n  });\n\n  afterEach(() => {\n    if (eventSource) {\n      eventSource.close();\n    }\n    jest.clearAllMocks();\n  });\n\n  describe('GET /mouse/position/stream', () => {\n    it('deve retornar 401 quando API key não for fornecida', async () => {\n      const response = await app.inject({\n        method: 'GET',\n        url: '/mouse/position/stream',\n      });\n\n      expect(response.statusCode).toBe(401);\n      expect(JSON.parse(response.body)).toEqual({\n        success: false,\n        error: 'Unauthorized',\n      });\n    });\n\n    it('deve retornar 401 quando API key for inválida', async () => {\n      const response = await app.inject({\n        method: 'GET',\n        url: '/mouse/position/stream',\n        headers: {\n          'x-api-key': 'invalid-key',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n\n    it('deve enviar stream de posições quando API key for válida', (done) => {\n      const receivedData: any[] = [];\n      const expectedMinEvents = 3;\n\n      // Criar EventSource com headers\n      eventSource = new EventSource(`${baseUrl}/mouse/position/stream`, {\n        headers: {\n          'x-api-key': environment.apiKey,\n        },\n      });\n\n      eventSource.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        receivedData.push(data);\n\n        // Verificar estrutura dos dados\n        expect(data).toHaveProperty('x');\n        expect(data).toHaveProperty('y');\n        expect(data).toHaveProperty('timestamp');\n        expect(typeof data.x).toBe('number');\n        expect(typeof data.y).toBe('number');\n        expect(typeof data.timestamp).toBe('number');\n\n        // Após receber eventos suficientes, verificar e encerrar\n        if (receivedData.length >= expectedMinEvents) {\n          eventSource.close();\n          \n          // Verificar que recebemos posições diferentes\n          expect(receivedData[0].x).toBe(100);\n          expect(receivedData[0].y).toBe(100);\n          expect(receivedData[1].x).toBe(150);\n          expect(receivedData[1].y).toBe(150);\n          \n          // Verificar que getPosition foi chamado múltiplas vezes\n          expect(mockMouseAdapter.getPosition).toHaveBeenCalledTimes(expectedMinEvents);\n          \n          done();\n        }\n      };\n\n      eventSource.onerror = (error) => {\n        done(error);\n      };\n    }, 10000); // Timeout de 10 segundos\n\n    it('deve parar de enviar eventos quando a conexão for fechada', (done) => {\n      let eventCount = 0;\n\n      eventSource = new EventSource(`${baseUrl}/mouse/position/stream`, {\n        headers: {\n          'x-api-key': environment.apiKey,\n        },\n      });\n\n      eventSource.onmessage = () => {\n        eventCount++;\n        \n        // Fechar após primeiro evento\n        if (eventCount === 1) {\n          eventSource.close();\n          \n          // Aguardar um pouco e verificar que não há mais chamadas\n          setTimeout(() => {\n            const callsAfterFirstEvent = mockMouseAdapter.getPosition.mock.calls.length;\n            \n            setTimeout(() => {\n              // Verificar que não houve novas chamadas\n              expect(mockMouseAdapter.getPosition).toHaveBeenCalledTimes(callsAfterFirstEvent);\n              done();\n            }, 200);\n          }, 100);\n        }\n      };\n\n      eventSource.onerror = (error) => {\n        done(error);\n      };\n    });\n  });\n\n  describe('Performance do streaming', () => {\n    it('deve enviar pelo menos 5 eventos em 1 segundo', (done) => {\n      const startTime = Date.now();\n      const receivedEvents: any[] = [];\n      const minExpectedEvents = 5;\n\n      eventSource = new EventSource(`${baseUrl}/mouse/position/stream`, {\n        headers: {\n          'x-api-key': environment.apiKey,\n        },\n      });\n\n      eventSource.onmessage = (event) => {\n        receivedEvents.push(JSON.parse(event.data));\n\n        const elapsedTime = Date.now() - startTime;\n        \n        // Após 1 segundo, verificar número de eventos\n        if (elapsedTime >= 1000) {\n          eventSource.close();\n          \n          expect(receivedEvents.length).toBeGreaterThanOrEqual(minExpectedEvents);\n          \n          // Verificar que os timestamps estão em ordem crescente\n          for (let i = 1; i < receivedEvents.length; i++) {\n            expect(receivedEvents[i].timestamp).toBeGreaterThan(receivedEvents[i - 1].timestamp);\n          }\n          \n          done();\n        }\n      };\n\n      eventSource.onerror = (error) => {\n        done(error);\n      };\n    }, 2000);\n  });\n});",
    "processedAt": "2025-07-01T19:40:19.902Z"
  },
  {
    "path": "tests/unit/adapters/nutjs-mouse.adapter.test.ts",
    "sha": "fbae4268fa9faa89d6807e645174dd60b1c855c8",
    "size": 7186,
    "summary": "Este arquivo contém testes unitários para a classe NutJSMouseAdapter, que atua como um adaptador para controle de mouse utilizando a biblioteca nut-js. O foco principal está na implementação de movimentos suaves do cursor com interpolação linear, além de operações comuns como clique simples, duplo clique, arrastar e scroll. Os testes verificam comportamentos como movimento instantâneo versus interpolado, manipulação de movimentos unidimensionais, execução correta da sequência de ações para drag-and-drop, mapeamento correto dos botões do mouse e a inversão de valores para scroll up/down. A abordagem de testes utiliza mocks para isolar dependências externas e timers falsos para simular o tempo, garantindo que o comportamento assíncrono e progressivo do movimento seja validado. O arquivo assegura que o adaptador respeite configurações de velocidade, realize interpolação progressiva e mantenha a integridade das ações do mouse, integrando-se de forma confiável com a biblioteca nut-js e abstraindo detalhes técnicos para o domínio da aplicação.",
    "content": "/**\n * Testes unitários para NutJSMouseAdapter\n * Foco na implementação de movimento suave com interpolação\n */\nimport 'reflect-metadata';\nimport { NutJSMouseAdapter } from '../../../src/infrastructure/adapters/nutjs/nutjs-mouse.adapter.js';\nimport { mouse, Button } from '@nut-tree-fork/nut-js';\nimport { MouseButton } from '../../../src/domain/entities/mouse-action.js';\nimport { MouseDefaults } from '../../../src/config/mouse.config.js';\n\n// Mock do nut-js\njest.mock('@nut-tree-fork/nut-js', () => ({\n  mouse: {\n    config: { mouseSpeed: 500 },\n    move: jest.fn().mockResolvedValue(undefined),\n    click: jest.fn().mockResolvedValue(undefined),\n    doubleClick: jest.fn().mockResolvedValue(undefined),\n    pressButton: jest.fn().mockResolvedValue(undefined),\n    releaseButton: jest.fn().mockResolvedValue(undefined),\n    scrollDown: jest.fn().mockResolvedValue(undefined),\n    getPosition: jest.fn().mockResolvedValue({ x: 0, y: 0 }),\n  },\n  straightTo: jest.fn((point) => point),\n  Button: {\n    LEFT: 'LEFT',\n    RIGHT: 'RIGHT',\n    MIDDLE: 'MIDDLE',\n  },\n  Point: jest.fn((x, y) => ({ x, y })),\n}));\n\ndescribe('NutJSMouseAdapter', () => {\n  let adapter: NutJSMouseAdapter;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.useFakeTimers();\n    adapter = new NutJSMouseAdapter();\n  });\n\n  afterEach(() => {\n    jest.useRealTimers();\n  });\n\n  describe('move', () => {\n    it('deve executar movimento instantâneo quando smooth for false', async () => {\n      await adapter.move({ x: 500, y: 500 }, false, 1000);\n\n      expect(mouse.config.mouseSpeed).toBe(10000);\n      expect(mouse.move).toHaveBeenCalledTimes(1);\n      expect(mouse.move).toHaveBeenCalledWith({ x: 500, y: 500 });\n    });\n\n    it('deve executar interpolação linear quando smooth for true', async () => {\n      // Configurar posição inicial\n      (mouse.getPosition as jest.Mock).mockResolvedValueOnce({ x: 100, y: 100 });\n\n      const targetPoint = { x: 400, y: 400 };\n      const duration = 1000; // 1 segundo\n      \n      // Calcular número esperado de passos\n      const expectedSteps = Math.floor(duration * MouseDefaults.sampleRate / 1000);\n\n      // Iniciar movimento\n      const movePromise = adapter.move(targetPoint, true, duration);\n\n      // Executar todos os timers\n      await jest.runAllTimersAsync();\n      await movePromise;\n\n      // Verificar número de chamadas\n      expect(mouse.move).toHaveBeenCalledTimes(expectedSteps);\n\n      // Verificar primeira e última posição\n      const firstCall = (mouse.move as jest.Mock).mock.calls[0][0];\n      const lastCall = (mouse.move as jest.Mock).mock.calls[expectedSteps - 1][0];\n\n      // Primeira posição deve estar próxima ao início\n      expect(firstCall.x).toBeGreaterThan(100);\n      expect(firstCall.x).toBeLessThan(150);\n\n      // Última posição deve ser exatamente o destino\n      expect(lastCall.x).toBe(400);\n      expect(lastCall.y).toBe(400);\n\n      // Verificar que as posições são progressivas\n      for (let i = 1; i < expectedSteps; i++) {\n        const prevCall = (mouse.move as jest.Mock).mock.calls[i - 1][0];\n        const currCall = (mouse.move as jest.Mock).mock.calls[i][0];\n        \n        // X e Y devem aumentar progressivamente\n        expect(currCall.x).toBeGreaterThanOrEqual(prevCall.x);\n        expect(currCall.y).toBeGreaterThanOrEqual(prevCall.y);\n      }\n    });\n\n    it('deve lidar com movimento em uma única dimensão', async () => {\n      (mouse.getPosition as jest.Mock).mockResolvedValueOnce({ x: 100, y: 200 });\n\n      // Movimento apenas horizontal\n      await adapter.move({ x: 500, y: 200 }, true, 500);\n      await jest.runAllTimersAsync();\n\n      const calls = (mouse.move as jest.Mock).mock.calls;\n      \n      // Y deve permanecer constante\n      calls.forEach(call => {\n        expect(call[0].y).toBe(200);\n      });\n\n      // X deve aumentar\n      expect(calls[calls.length - 1][0].x).toBe(500);\n    });\n\n    it('deve executar pelo menos um passo mesmo com duração muito curta', async () => {\n      (mouse.getPosition as jest.Mock).mockResolvedValueOnce({ x: 0, y: 0 });\n\n      await adapter.move({ x: 100, y: 100 }, true, 10); // 10ms\n      await jest.runAllTimersAsync();\n\n      expect(mouse.move).toHaveBeenCalledTimes(1);\n      expect(mouse.move).toHaveBeenCalledWith({ x: 100, y: 100 });\n    });\n  });\n\n  describe('drag', () => {\n    it('deve executar sequência correta de ações para arrastar', async () => {\n      const from = { x: 100, y: 100 };\n      const to = { x: 500, y: 500 };\n      const duration = 900;\n\n      await adapter.drag(from, to, duration);\n      await jest.runAllTimersAsync();\n\n      // Verificar sequência de chamadas\n      const moveCalls = (mouse.move as jest.Mock).mock.calls;\n      \n      // Deve ter movido para posição inicial\n      expect(moveCalls[0][0]).toMatchObject(from);\n      \n      // Deve ter pressionado o botão\n      expect(mouse.pressButton).toHaveBeenCalledWith(Button.LEFT);\n      \n      // Deve ter movido para posição final\n      const lastMoveCall = moveCalls[moveCalls.length - 1][0];\n      expect(lastMoveCall).toMatchObject(to);\n      \n      // Deve ter soltado o botão\n      expect(mouse.releaseButton).toHaveBeenCalledWith(Button.LEFT);\n    });\n  });\n\n  describe('click', () => {\n    it('deve mapear botões corretamente', async () => {\n      await adapter.click(MouseButton.LEFT, false);\n      expect(mouse.click).toHaveBeenCalledWith(Button.LEFT);\n\n      await adapter.click(MouseButton.RIGHT, false);\n      expect(mouse.click).toHaveBeenCalledWith(Button.RIGHT);\n\n      await adapter.click(MouseButton.MIDDLE, false);\n      expect(mouse.click).toHaveBeenCalledWith(Button.MIDDLE);\n    });\n\n    it('deve executar double click quando solicitado', async () => {\n      await adapter.click(MouseButton.LEFT, true);\n      expect(mouse.doubleClick).toHaveBeenCalledWith(Button.LEFT);\n      expect(mouse.click).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('clickAt', () => {\n    it('deve mover antes de clicar', async () => {\n      const point = { x: 250, y: 250 };\n      \n      await adapter.clickAt(point, MouseButton.RIGHT, false);\n      await jest.runAllTimersAsync();\n\n      // Verificar que moveu primeiro\n      expect(mouse.move).toHaveBeenCalled();\n      const moveCall = (mouse.move as jest.Mock).mock.calls[0][0];\n      expect(moveCall.x).toBe(250);\n      expect(moveCall.y).toBe(250);\n\n      // Verificar que clicou depois\n      expect(mouse.click).toHaveBeenCalledWith(Button.RIGHT);\n    });\n  });\n\n  describe('scroll', () => {\n    it('deve inverter o valor para scroll up', async () => {\n      await adapter.scroll('up', 5);\n      expect(mouse.scrollDown).toHaveBeenCalledWith(-5);\n    });\n\n    it('deve manter o valor positivo para scroll down', async () => {\n      await adapter.scroll('down', 3);\n      expect(mouse.scrollDown).toHaveBeenCalledWith(3);\n    });\n  });\n\n  describe('getPosition', () => {\n    it('deve retornar a posição atual do mouse', async () => {\n      (mouse.getPosition as jest.Mock).mockResolvedValueOnce({ x: 123, y: 456 });\n      \n      const position = await adapter.getPosition();\n      \n      expect(position).toEqual({ x: 123, y: 456 });\n    });\n  });\n});",
    "processedAt": "2025-07-01T19:40:22.788Z"
  }
]