[
  {
    "path": "src/index.ts",
    "sha": "51208f37e56e9daa5eaa4908db3af1d747eacb15",
    "size": 3212,
    "summary": "Este arquivo implementa um servidor HTTP utilizando o framework Fastify, configurado para servir uma API RESTful e uma aplicação web SPA (Single Page Application). Ele realiza a injeção de dependências para inicializar serviços essenciais da aplicação, registra rotas específicas para automação, e gerencia o tratamento de erros e rotas não encontradas com lógica diferenciada para APIs e recursos estáticos. O servidor também expõe um endpoint de health check para monitoramento, suporta logs configuráveis conforme o ambiente, e implementa um mecanismo de shutdown gracioso para garantir encerramento seguro. A arquitetura modular e o uso de middlewares facilitam a manutenção e escalabilidade do sistema, integrando componentes de configuração, rotas, serviços e middleware de forma coesa e orientada a boas práticas de desenvolvimento backend moderno.",
    "content": "import 'reflect-metadata';\nimport Fastify from 'fastify';\nimport fastifyStatic from '@fastify/static';\nimport type { FastifyRequest, FastifyReply } from 'fastify';\nimport { automationRoutes } from './routes/automation.routes.js';\nimport { errorHandler } from './interface/middleware/error-handler.middleware.js';\nimport { configureDependencies, container } from './config/dependency-injection.js';\nimport { ApplicationStartupService } from './application/services/application-startup.service.js';\nimport { environment } from './config/environment.js';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconfigureDependencies();\n\nconst createServer = async () => {\n  const server = Fastify({\n    logger: {\n      level: environment.logLevel,\n      transport:\n        environment.nodeEnv === 'development'\n          ? {\n              target: 'pino-pretty',\n              options: {\n                colorize: true,\n                ignore: 'pid,hostname',\n                translateTime: 'HH:MM:ss Z',\n              },\n            }\n          : undefined,\n    },\n  });\n\n  // Registrar rotas da API primeiro\n  await server.register(automationRoutes, { prefix: '/api/v1' });\n\n  // Health check\n  server.get('/health', async (_request: FastifyRequest, reply: FastifyReply) => {\n    await reply.send({\n      status: 'ok',\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      environment: environment.nodeEnv,\n    });\n  });\n\n  // Registrar servir arquivos estáticos da web com configuração para não conflitar com API\n  await server.register(fastifyStatic, {\n    root: path.join(__dirname, '..', 'dist', 'web'),\n    prefix: '/',\n    wildcard: false, // Desabilita wildcard para evitar conflitos com rotas da API\n  });\n\n  server.setErrorHandler(errorHandler);\n\n  // Catch-all para SPA - serve index.html para rotas não encontradas (exceto /api)\n  server.setNotFoundHandler(async (request: FastifyRequest, reply: FastifyReply) => {\n    // Se for uma rota da API, retorna 404 normal\n    if (request.url.startsWith('/api/')) {\n      return reply.code(404).send({\n        success: false,\n        error: 'Route not found',\n      });\n    }\n    // Senão, retorna o index.html para o SPA\n    return reply.sendFile('index.html');\n  });\n\n  return server;\n};\n\nconst start = async () => {\n  try {\n    const server = await createServer();\n\n    // Inicializar serviços da aplicação\n    const startupService = container.resolve(ApplicationStartupService);\n    await startupService.initialize();\n\n    await server.listen({ port: environment.port, host: environment.host });\n    server.log.info(`Server listening on http://${environment.host}:${environment.port}`);\n\n    // Graceful shutdown\n    const gracefulShutdown = async (signal: string) => {\n      server.log.info(`${signal} received, closing server gracefully`);\n      await server.close();\n      process.exit(0);\n    };\n\n    process.on('SIGTERM', () => void gracefulShutdown('SIGTERM'));\n    process.on('SIGINT', () => void gracefulShutdown('SIGINT'));\n  } catch (err) {\n    console.error(err);\n    process.exit(1);\n  }\n};\n\nvoid start();\n",
    "processedAt": "2025-07-06T17:28:25.717Z"
  },
  {
    "path": "web/webpack.config.js",
    "sha": "35527da86975eb28f44417f5e807fd6104a65696",
    "size": 1128,
    "summary": "Este arquivo configura o ambiente de build e desenvolvimento para uma aplicação web front-end escrita em TypeScript com React. Ele utiliza Webpack para empacotamento de módulos, incluindo suporte para arquivos TypeScript (.tsx/.ts), CSS e assets de imagem, garantindo uma pipeline eficiente para transformar e otimizar o código fonte. Além disso, configura um servidor de desenvolvimento com hot-reload, proxy para backend local e compressão, facilitando o desenvolvimento ágil e integração com APIs. O uso do HtmlWebpackPlugin automatiza a geração do arquivo HTML base, injetando o bundle gerado, o que simplifica o deploy e a manutenção do front-end. A configuração é orientada para ambientes de desenvolvimento e produção, com hash no nome do bundle para cache busting e limpeza automática da pasta de saída, promovendo uma entrega consistente e otimizada do front-end.",
    "content": "const path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n  mode: process.env.NODE_ENV || 'development',\n  entry: path.resolve(__dirname, './src/index.tsx'),\n  context: __dirname,\n  output: {\n    path: path.resolve(__dirname, '../dist/web'),\n    filename: 'bundle.[contenthash].js',\n    clean: true,\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.(png|svg|jpg|jpeg|gif)$/i,\n        type: 'asset/resource',\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname, './public/index.html'),\n      inject: 'body',\n    }),\n  ],\n  devServer: {\n    static: {\n      directory: path.join(__dirname, 'public'),\n    },\n    compress: true,\n    port: 3001,\n    hot: true,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:3000',\n        changeOrigin: true,\n      },\n    },\n  },\n};\n",
    "processedAt": "2025-07-06T17:28:26.721Z"
  },
  {
    "path": "src/routes/status.routes.ts",
    "sha": "54a2757be37d2de33f954c160499f24539ce86e0",
    "size": 960,
    "summary": "Este arquivo define um conjunto de rotas para monitoramento do status da API utilizando o framework Fastify. A principal funcionalidade é expor um endpoint GET /status que retorna informações sobre a saúde da aplicação, incluindo um indicador booleano de operação, latência calculada em milissegundos e timestamp da verificação. O código é projetado para ser simples e eficiente, permitindo que o frontend ou sistemas externos verifiquem rapidamente se a API está operacional, facilitando monitoramento e alertas automáticos. Em caso de erro, a rota responde com status HTTP 503 e mensagem apropriada, garantindo transparência no estado do serviço. A abordagem modular permite fácil integração e extensão dentro de uma arquitetura maior baseada em Fastify.",
    "content": "import type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\n\n/**\n * Rotas para verificação de status da API\n * Usado pelo frontend para monitorar saúde da aplicação\n */\nexport const statusRoutes = (fastify: FastifyInstance) => {\n  /**\n   * GET /status\n   * Retorna o status atual da API\n   */\n  fastify.get('/status', async (_request: FastifyRequest, reply: FastifyReply) => {\n    const startTime = Date.now();\n\n    try {\n      // Calcula latência como tempo de processamento\n      const latency = Date.now() - startTime;\n\n      return reply.send({\n        ok: true,\n        latency,\n        message: 'API is operational',\n        checkedAt: new Date().toISOString(),\n      });\n    } catch (error) {\n      const latency = Date.now() - startTime;\n\n      return reply.code(503).send({\n        ok: false,\n        latency,\n        message: 'API is experiencing issues',\n        checkedAt: new Date().toISOString(),\n      });\n    }\n  });\n};\n",
    "processedAt": "2025-07-06T17:28:37.038Z"
  },
  {
    "path": "tests/unit/routes/automation.routes.test.ts",
    "sha": "3b86fc6636f298b90b8f893f358d54a8ba15e431",
    "size": 6681,
    "summary": "O arquivo de teste automatizado foca na validação do comportamento do módulo de rotas de automação em um servidor Fastify, garantindo que múltiplos controllers e rotas sejam registrados corretamente e na ordem esperada. Ele simula a integração dos controllers AutomationController, KeyboardController e LLMController, além das rotas inputEventsRoutes e statusRoutes, verificando a correta invocação de métodos como registerRoutes e buildRoutes, o tratamento de callbacks assíncronos e a robustez frente a falhas de registro. O código assegura que o sistema modular de rotas funcione de forma isolada e integrada, suportando múltiplas execuções independentes e propagando erros adequadamente, o que é essencial para a estabilidade e escalabilidade da aplicação backend.",
    "content": "// Mock dos controllers e rotas\njest.mock('../../../src/interface/controllers/automation.controller', () => ({\n  AutomationController: jest.fn().mockImplementation(() => ({\n    registerRoutes: jest.fn(),\n  })),\n}));\n\njest.mock('../../../src/interface/controllers/keyboard.controller', () => ({\n  KeyboardController: {\n    buildRoutes: jest.fn((fastify, opts, done) => {\n      done();\n    }),\n  },\n}));\n\njest.mock('../../../src/routes/input-events.routes', () => ({\n  inputEventsRoutes: jest.fn(),\n}));\n\njest.mock('../../../src/interface/controllers/llm.controller', () => ({\n  LLMController: jest.fn().mockImplementation(() => ({\n    registerRoutes: jest.fn(),\n  })),\n}));\n\njest.mock('../../../src/routes/status.routes', () => ({\n  statusRoutes: jest.fn(),\n}));\n\n// Usar require devido ao verbatimModuleSyntax\nconst { automationRoutes } = require('../../../src/routes/automation.routes');\nconst {\n  AutomationController,\n} = require('../../../src/interface/controllers/automation.controller');\nconst { KeyboardController } = require('../../../src/interface/controllers/keyboard.controller');\nconst { LLMController } = require('../../../src/interface/controllers/llm.controller');\nconst { inputEventsRoutes } = require('../../../src/routes/input-events.routes');\nconst { statusRoutes } = require('../../../src/routes/status.routes');\n\ndescribe('automation.routes', () => {\n  let mockServer: any;\n  let mockRegisterOptions: any;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Mock do Fastify server com todas as propriedades necessárias\n    mockRegisterOptions = {\n      registeredRoutes: [] as any[],\n    };\n\n    mockServer = {\n      register: jest.fn((plugin: any, opts?: any) => {\n        // Se plugin é uma função, executá-la\n        if (typeof plugin === 'function' && plugin.length === 3) {\n          // É um plugin que espera (fastify, opts, done)\n          const mockDone = jest.fn();\n          plugin(mockServer, opts || {}, mockDone);\n          mockRegisterOptions.registeredRoutes.push({ plugin, opts });\n        } else {\n          // É um plugin async\n          mockRegisterOptions.registeredRoutes.push({ plugin, opts });\n        }\n        return Promise.resolve();\n      }),\n      get: jest.fn(),\n      post: jest.fn(),\n      put: jest.fn(),\n      delete: jest.fn(),\n      head: jest.fn(),\n      patch: jest.fn(),\n      options: jest.fn(),\n    };\n  });\n\n  test('should register automation controller routes', async () => {\n    await automationRoutes(mockServer, {}, jest.fn());\n\n    // Verificar que AutomationController foi instanciado\n    expect(AutomationController).toHaveBeenCalledTimes(1);\n\n    // Verificar que registerRoutes foi chamado\n    const controllerInstance = (AutomationController as jest.Mock).mock.results[0].value;\n    expect(controllerInstance.registerRoutes).toHaveBeenCalledWith(mockServer);\n  });\n\n  test('should register keyboard controller routes', async () => {\n    await automationRoutes(mockServer, {}, jest.fn());\n\n    // Verificar que register foi chamado para keyboard routes\n    expect(mockServer.register).toHaveBeenCalled();\n\n    // Verificar que KeyboardController.buildRoutes foi chamado\n    expect(KeyboardController.buildRoutes).toHaveBeenCalledWith(\n      mockServer,\n      expect.any(Object),\n      expect.any(Function),\n    );\n  });\n\n  test('should register LLM controller routes', async () => {\n    await automationRoutes(mockServer, {}, jest.fn());\n\n    // Verificar que LLMController foi instanciado\n    expect(LLMController).toHaveBeenCalledTimes(1);\n\n    // Verificar que registerRoutes foi chamado\n    const llmControllerInstance = (LLMController as jest.Mock).mock.results[0].value;\n    expect(llmControllerInstance.registerRoutes).toHaveBeenCalledWith(mockServer);\n  });\n\n  test('should register input events routes with prefix', async () => {\n    await automationRoutes(mockServer, {}, jest.fn());\n\n    // Verificar que inputEventsRoutes foi registrado com prefix correto\n    expect(mockServer.register).toHaveBeenCalledWith(inputEventsRoutes, { prefix: '/stream' });\n  });\n\n  test('should register all routes in correct order', async () => {\n    await automationRoutes(mockServer, {}, jest.fn());\n\n    // Verificar que todas as rotas foram registradas\n    expect(mockServer.register).toHaveBeenCalledTimes(3);\n\n    // Verificar ordem de registro\n    const registerCalls = (mockServer.register as jest.Mock).mock.calls;\n\n    // Primeira chamada: keyboard routes (função inline)\n    expect(typeof registerCalls[0][0]).toBe('function');\n\n    // Segunda chamada: status routes\n    expect(registerCalls[1][0]).toBe(statusRoutes);\n\n    // Terceira chamada: input events routes com prefix\n    expect(registerCalls[2][0]).toBe(inputEventsRoutes);\n    expect(registerCalls[2][1]).toEqual({ prefix: '/stream' });\n  });\n\n  test('should handle async registration properly', async () => {\n    // Simular falha de registro\n    const errorMessage = 'Registration failed';\n    mockServer.register.mockRejectedValueOnce(new Error(errorMessage));\n\n    await expect(automationRoutes(mockServer, {}, jest.fn())).rejects.toThrow(errorMessage);\n  });\n\n  test('should pass options to automation routes plugin', async () => {\n    const customOptions = { customOption: 'test' };\n    const mockDone = jest.fn();\n\n    await automationRoutes(mockServer, customOptions, mockDone);\n\n    // Verificar que o plugin foi executado com as opções corretas\n    expect(AutomationController).toHaveBeenCalledTimes(1);\n  });\n\n  test('should complete done callback for keyboard routes', async () => {\n    // Limpar mock anterior\n    KeyboardController.buildRoutes.mockClear();\n\n    // Mock para capturar o callback done\n    let capturedDone: any;\n    KeyboardController.buildRoutes.mockImplementation((fastify: any, opts: any, done: any) => {\n      capturedDone = done;\n      done();\n    });\n\n    await automationRoutes(mockServer, {}, jest.fn());\n\n    // Verificar que done foi chamado\n    expect(capturedDone).toBeDefined();\n    expect(typeof capturedDone).toBe('function');\n  });\n\n  test('should handle multiple registrations independently', async () => {\n    // Executar automationRoutes múltiplas vezes\n    await automationRoutes(mockServer, {}, jest.fn());\n    await automationRoutes(mockServer, {}, jest.fn());\n\n    // Cada execução deve criar nova instância do controller\n    expect(AutomationController).toHaveBeenCalledTimes(2);\n\n    // Cada instância deve ter seu próprio registerRoutes chamado\n    const instances = (AutomationController as jest.Mock).mock.results;\n    expect(instances[0].value.registerRoutes).toHaveBeenCalledTimes(1);\n    expect(instances[1].value.registerRoutes).toHaveBeenCalledTimes(1);\n  });\n});\n",
    "processedAt": "2025-07-06T17:28:41.225Z"
  },
  {
    "path": "src/routes/automation.routes.ts",
    "sha": "fc44756e51206ff9334df55ab0aef3c4eca6a1d5",
    "size": 1041,
    "summary": "O arquivo define um conjunto de rotas assíncronas para um servidor Fastify, centralizando a orquestração de múltiplos controladores responsáveis por automação, manipulação de teclado, integração com Large Language Models (LLM), status do sistema e streaming de eventos de input. Seu comportamento principal é registrar e expor endpoints HTTP que habilitam funcionalidades de automação e interação com dispositivos e serviços externos, promovendo modularidade e escalabilidade na arquitetura do backend. Através da composição de plugins e controllers, o código integra diferentes domínios funcionais, facilitando a manutenção e extensão do sistema, além de garantir que as rotas estejam organizadas e prefixadas conforme o contexto de uso.",
    "content": "import type { FastifyPluginAsync } from 'fastify';\nimport { AutomationController } from '../interface/controllers/automation.controller.js';\nimport { KeyboardController } from '../interface/controllers/keyboard.controller.js';\nimport { LLMController } from '../interface/controllers/llm.controller.js';\nimport { inputEventsRoutes } from './input-events.routes.js';\nimport { statusRoutes } from './status.routes.js';\n\nexport const automationRoutes: FastifyPluginAsync = async (server) => {\n  const controller = new AutomationController();\n  controller.registerRoutes(server);\n\n  // Registra rotas de keyboard e clipboard\n  await server.register((fastify, opts, done) => {\n    KeyboardController.buildRoutes(fastify, opts, done);\n  });\n\n  // Registra rotas de LLM\n  const llmController = new LLMController();\n  llmController.registerRoutes(server);\n\n  // Registra rotas de status\n  await server.register(statusRoutes);\n\n  // Registra rotas de streaming de eventos de input\n  await server.register(inputEventsRoutes, { prefix: '/stream' });\n};\n",
    "processedAt": "2025-07-06T17:28:41.293Z"
  },
  {
    "path": "package.json",
    "sha": "c86c17e8833f5af81d7ba88c3de37fba583ab248",
    "size": 2905,
    "summary": "O projeto nutjs-rest-api é uma API REST que serve como um wrapper para a automação desktop utilizando a biblioteca NutJS. Seu principal objetivo é expor funcionalidades de automação de interface gráfica via endpoints HTTP, permitindo que clientes controlem ações no desktop de forma programática. O sistema integra diversas bibliotecas para manipulação de eventos globais, captura de tela, e automação de teclado e mouse, além de oferecer suporte para desenvolvimento frontend com React e Bootstrap. A arquitetura modular e o uso de TypeScript garantem tipagem estática e manutenção facilitada, enquanto o uso de ferramentas como Jest, ESLint e Prettier assegura qualidade e padronização do código. O projeto está estruturado para suportar desenvolvimento local com hot-reload, testes unitários e integração contínua, visando um produto robusto e escalável para automação desktop via API REST.",
    "content": "{\n  \"name\": \"nutjs-rest-api\",\n  \"version\": \"1.0.1\",\n  \"type\": \"module\",\n  \"description\": \"REST API wrapper for NutJS desktop automation\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"dev\": \"concurrently \\\"webpack --watch --mode development --config web/webpack.config.js\\\" \\\"tsx watch src/index.ts\\\"\",\n    \"dev:web\": \"webpack serve --mode development --config web/webpack.config.cjs\",\n    \"build\": \"tsc -p tsconfig.json && npm run build:web\",\n    \"build:web\": \"webpack --mode production --config web/webpack.config.js\",\n    \"build:prod\": \"tsc -p tsconfig.prod.json && npm run build:web\",\n    \"start\": \"node dist/index.js\",\n    \"test\": \"jest\",\n    \"test:unit\": \"jest tests/unit\",\n    \"test:integration\": \"jest tests/integration\",\n    \"test:coverage\": \"jest --coverage\",\n    \"test:api\": \"tsx src/test-endpoint.ts\",\n    \"lint\": \"eslint src/**/*.ts\",\n    \"lint:fix\": \"eslint src/**/*.ts --fix\",\n    \"format\": \"prettier --write src/**/*.ts\",\n    \"format:check\": \"prettier --check src/**/*.ts\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"audit:roadmap\": \"echo 'TODO: Implement roadmap audit script'\",\n    \"clean\": \"rm -rf dist coverage .nyc_output\",\n    \"prepare\": \"husky\"\n  },\n  \"dependencies\": {\n    \"@fastify/static\": \"^6.12.0\",\n    \"@langchain/core\": \"^0.3.62\",\n    \"@langchain/deepseek\": \"^0.0.2\",\n    \"@langchain/openai\": \"^0.5.18\",\n    \"@nut-tree-fork/nut-js\": \"^4.2.0\",\n    \"bootstrap\": \"^5.3.2\",\n    \"clipboardy\": \"^4.0.0\",\n    \"concurrently\": \"^8.2.2\",\n    \"dotenv\": \"^16.3.1\",\n    \"fastify\": \"^4.24.0\",\n    \"nanoid\": \"^5.1.5\",\n    \"node-global-key-listener\": \"^0.3.0\",\n    \"pino\": \"^8.16.0\",\n    \"pino-pretty\": \"^10.3.0\",\n    \"react\": \"^18.2.0\",\n    \"react-bootstrap\": \"^2.9.1\",\n    \"react-dom\": \"^18.2.0\",\n    \"reflect-metadata\": \"^0.2.1\",\n    \"robotjs\": \"^0.6.0\",\n    \"sharp\": \"^0.34.2\",\n    \"tsyringe\": \"^4.8.0\",\n    \"uiohook-napi\": \"^1.5.4\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"devDependencies\": {\n    \"@types/clipboardy\": \"^1.1.0\",\n    \"@types/eventsource\": \"^1.1.15\",\n    \"@types/jest\": \"^29.5.11\",\n    \"@types/node\": \"^20.10.0\",\n    \"@types/react\": \"^18.2.38\",\n    \"@types/react-dom\": \"^18.2.17\",\n    \"@types/sharp\": \"^0.31.1\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.12.0\",\n    \"@typescript-eslint/parser\": \"^6.12.0\",\n    \"css-loader\": \"^6.8.1\",\n    \"eslint\": \"^8.54.0\",\n    \"eslint-config-prettier\": \"^9.0.0\",\n    \"eslint-plugin-prettier\": \"^5.0.1\",\n    \"eventsource\": \"^2.0.2\",\n    \"html-webpack-plugin\": \"^5.5.3\",\n    \"husky\": \"^9.1.7\",\n    \"jest\": \"^29.7.0\",\n    \"lint-staged\": \"^16.1.2\",\n    \"prettier\": \"^3.1.0\",\n    \"style-loader\": \"^3.3.3\",\n    \"ts-jest\": \"^29.1.1\",\n    \"ts-loader\": \"^9.5.1\",\n    \"tsx\": \"^4.6.0\",\n    \"typescript\": \"^5.3.2\",\n    \"webpack\": \"^5.89.0\",\n    \"webpack-cli\": \"^5.1.4\",\n    \"webpack-dev-server\": \"^4.15.1\"\n  },\n  \"lint-staged\": {\n    \"**/*.{ts,tsx,js,jsx}\": [\n      \"prettier --write\"\n    ],\n    \"**/*.{json,md,yml,yaml}\": [\n      \"prettier --write\"\n    ]\n  }\n}\n",
    "processedAt": "2025-07-06T17:28:49.539Z"
  }
]
