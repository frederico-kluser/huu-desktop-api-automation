[
  {
    "path": ".eslintrc.cjs",
    "sha": "7291243ec2a99c686d0297c5a4c5c1cdca739768",
    "size": 687,
    "summary": "Este arquivo configura o ESLint para um projeto TypeScript moderno, definindo regras rigorosas de linting que garantem a qualidade e a consistência do código. Ele utiliza o parser '@typescript-eslint/parser' para interpretar sintaxe TypeScript avançada e integra plugins recomendados para TypeScript e Prettier, assegurando conformidade com padrões de estilo e melhores práticas. As regras aplicadas previnem erros comuns como uso incorreto de async/await, variáveis não utilizadas e tipos explícitos 'any', promovendo código mais seguro, legível e sustentável em ambientes de desenvolvimento colaborativos.",
    "content": "module.exports = {\n  parser: '@typescript-eslint/parser',\n  parserOptions: {\n    ecmaVersion: 2022,\n    sourceType: 'module',\n    project: './tsconfig.json',\n  },\n  extends: [\n    'eslint:recommended',\n    'plugin:@typescript-eslint/recommended',\n    'plugin:@typescript-eslint/recommended-requiring-type-checking',\n    'plugin:prettier/recommended',\n  ],\n  rules: {\n    'no-async-promise-executor': 'error',\n    'no-await-in-loop': 'warn',\n    '@typescript-eslint/no-explicit-any': 'error',\n    '@typescript-eslint/no-floating-promises': 'error',\n    '@typescript-eslint/await-thenable': 'error',\n    '@typescript-eslint/no-unused-vars': ['error', { 'argsIgnorePattern': '^_' }],\n  }\n};",
    "processedAt": "2025-07-01T20:20:35.430Z"
  },
  {
    "path": "src/config/dependency-injection.ts",
    "sha": "488e918452f0264a84032109dc023cc28ef38b30",
    "size": 1651,
    "summary": "Este arquivo é responsável pela configuração e registro das dependências do sistema utilizando o container de injeção de dependências do tsyringe. Ele centraliza a associação entre interfaces e suas implementações concretas, especialmente adaptadores para dispositivos de entrada e saída (mouse, teclado, tela, clipboard) e serviços de automação. O código promove a inversão de controle, facilitando a manutenção, testabilidade e extensibilidade do sistema, ao permitir que componentes sejam facilmente substituídos ou mockados. A configuração abrange serviços de alto nível que encapsulam funcionalidades específicas, como controle do mouse, teclado, captura de tela e automação, integrando-os com adaptadores baseados na biblioteca NutJS. Dessa forma, o arquivo habilita a orquestração de automações complexas no domínio de controle de dispositivos, garantindo uma arquitetura modular e desacoplada, essencial para sistemas que executam automações de interface e interação com o usuário.",
    "content": "import 'reflect-metadata';\nimport { container } from 'tsyringe';\nimport { MouseService } from '../application/services/mouse.service.js';\nimport { ScreenService } from '../application/services/screen.service.js';\nimport { AutomationService } from '../application/services/automation.service.js';\nimport { KeyboardService } from '../application/services/keyboard.service.js';\nimport { ClipboardService } from '../application/services/clipboard.service.js';\nimport { NutJSMouseAdapter } from '../infrastructure/adapters/nutjs/nutjs-mouse.adapter.js';\nimport { NutJSScreenAdapter } from '../infrastructure/adapters/nutjs/nutjs-screen.adapter.js';\nimport { NutJSKeyboardAdapter } from '../infrastructure/adapters/nutjs/nutjs-keyboard.adapter.js';\nimport { ExecuteAutomationUseCase } from '../domain/use-cases/execute-automation.use-case.js';\n\nexport function configureDependencies(): void {\n  container.register('MouseAdapter', {\n    useClass: NutJSMouseAdapter,\n  });\n\n  container.register('ScreenAdapter', {\n    useClass: NutJSScreenAdapter,\n  });\n\n  container.register('MouseService', {\n    useClass: MouseService,\n  });\n\n  container.register('ScreenService', {\n    useClass: ScreenService,\n  });\n\n  container.register('AutomationService', {\n    useClass: AutomationService,\n  });\n\n  container.register('ExecuteAutomationUseCase', {\n    useClass: ExecuteAutomationUseCase,\n  });\n\n  container.register('IKeyboardAdapter', {\n    useClass: NutJSKeyboardAdapter,\n  });\n\n  container.register('KeyboardService', {\n    useClass: KeyboardService,\n  });\n\n  container.register('ClipboardService', {\n    useClass: ClipboardService,\n  });\n}\n\nexport { container };\n",
    "processedAt": "2025-07-01T20:20:41.311Z"
  },
  {
    "path": "src/application/dto/keyboard-request.dto.ts",
    "sha": "06c982d90cad84ce699f2fdad19947c23b8308fe",
    "size": 2593,
    "summary": "Este arquivo define Data Transfer Objects (DTOs) para operações relacionadas a teclado, utilizando a biblioteca Zod para validação rigorosa dos dados de entrada. Ele oferece schemas específicos para digitação de texto com controle de timing, pressionamento de teclas individuais e combinações de teclas, garantindo integridade e conformidade com regras de negócio como limites de tamanho, tipos e valores permitidos. O código foca em validar entradas para ações de teclado, assegurando que apenas teclas suportadas e formatos corretos sejam aceitos, o que é essencial para automação, testes ou simulação de eventos de teclado em sistemas maiores. A abordagem modular e tipada facilita a integração com outras partes do sistema, promovendo segurança e robustez na manipulação de eventos de teclado.",
    "content": "/**\n * DTOs para requisições relacionadas a operações de teclado\n * Define schemas de validação usando Zod para garantir integridade dos dados\n */\n\nimport { z } from 'zod';\n\n/**\n * Schema para digitação de texto com opções de timing\n */\nexport const keyboardTypeSchema = z.object({\n  text: z.string()\n    .min(1, 'Text cannot be empty')\n    .max(10000, 'Text exceeds maximum length of 10000 characters')\n    .refine(\n      (text) => {\n        // Remove caracteres de controle perigosos para validação\n        const sanitized = text.replace(/[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F]/g, '');\n        return sanitized.length > 0;\n      },\n      'Text cannot contain only control characters'\n    ),\n  mode: z.enum(['instant', 'perChar', 'total']).optional().default('instant'),\n  value: z.number()\n    .int('Value must be an integer')\n    .nonnegative('Value must be non-negative')\n    .max(300000, 'Value exceeds maximum of 300000ms (5 minutes)')\n    .optional()\n});\n\n/**\n * Schema para pressionar uma tecla específica\n */\nexport const keyboardPressKeySchema = z.object({\n  key: z.string()\n    .min(1, 'Key cannot be empty')\n    .transform(val => val.toLowerCase())\n    .refine(\n      (key) => {\n        const supportedKeys = [\n          'enter', 'tab', 'escape', 'space', 'backspace', 'delete',\n          'up', 'down', 'left', 'right', 'home', 'end',\n          'pageup', 'pagedown', 'f1', 'f2', 'f3', 'f4',\n          'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12'\n        ];\n        return supportedKeys.includes(key);\n      },\n      'Unsupported key. Valid keys: enter, tab, escape, space, backspace, delete, arrow keys, home, end, pageup, pagedown, f1-f12'\n    )\n});\n\n/**\n * Schema para combinação de teclas\n */\nexport const keyboardCombinationSchema = z.object({\n  keys: z.array(z.string())\n    .min(1, 'Key combination requires at least one key')\n    .max(5, 'Key combination supports maximum 5 keys')\n    .refine(\n      (keys) => {\n        const supportedKeys = [\n          'ctrl', 'control', 'alt', 'shift', 'cmd', 'command', 'meta', 'win',\n          'a', 'c', 'v', 'x', 'z', 'y'\n        ];\n        return keys.every(key => supportedKeys.includes(key.toLowerCase()));\n      },\n      'Unsupported key in combination. Valid modifier keys: ctrl, alt, shift, cmd/win. Valid letter keys: a, c, v, x, z, y'\n    )\n});\n\n/**\n * Tipos inferidos dos schemas\n */\nexport type KeyboardTypeRequest = z.infer<typeof keyboardTypeSchema>;\nexport type KeyboardPressKeyRequest = z.infer<typeof keyboardPressKeySchema>;\nexport type KeyboardCombinationRequest = z.infer<typeof keyboardCombinationSchema>;",
    "processedAt": "2025-07-01T20:20:42.376Z"
  },
  {
    "path": "src/config/environment.ts",
    "sha": "4f705b036580807f52af2a2b426c165093d6ad60",
    "size": 591,
    "summary": "Este arquivo configura o ambiente de execução da aplicação Node.js, carregando variáveis de ambiente via dotenv e definindo um objeto imutável com parâmetros essenciais como NODE_ENV, porta, host, nível de log, velocidade do mouse, confiança da tela e chave de API. Ele centraliza a configuração, garantindo valores padrão para cada variável, facilitando a adaptação entre ambientes de desenvolvimento e produção. Além disso, expõe flags booleanas para identificar o ambiente atual, permitindo decisões condicionais em outras partes do sistema, promovendo flexibilidade e controle centralizado das configurações críticas da aplicação.",
    "content": "import { config } from 'dotenv';\n\nconfig();\n\nexport const environment = {\n  nodeEnv: process.env.NODE_ENV || 'development',\n  port: parseInt(process.env.PORT || '3000', 10),\n  host: process.env.HOST || '0.0.0.0',\n  logLevel: process.env.LOG_LEVEL || 'info',\n  mouseSpeed: parseInt(process.env.MOUSE_SPEED || '500', 10),\n  screenConfidence: parseFloat(process.env.SCREEN_CONFIDENCE || '0.8'),\n  apiKey: process.env.API_KEY || 'default-api-key',\n} as const;\n\nexport const isDevelopment = environment.nodeEnv === 'development';\nexport const isProduction = environment.nodeEnv === 'production';\n",
    "processedAt": "2025-07-01T20:20:42.750Z"
  },
  {
    "path": "src/application/services/automation.service.ts",
    "sha": "5c435ee88205247b175f6be69b4af3b0131cccbb",
    "size": 4368,
    "summary": "O arquivo define a classe AutomationService, responsável por executar comandos de automação relacionados a mouse e tela, integrando serviços especializados para manipulação de ações como movimento, clique, arraste, rolagem e captura ou busca de imagens na tela. Ele implementa uma interface de execução de automações, tratando diferentes tipos de comandos e operações com validação e tratamento de erros robusto, garantindo respostas padronizadas. A arquitetura modular e injeção de dependências facilitam a extensão e manutenção, permitindo que o serviço coordene ações complexas de automação de interface gráfica de forma assíncrona e confiável.",
    "content": "import { injectable, inject } from 'tsyringe';\nimport type {\n  AutomationCommand,\n  CommandResult,\n  MouseCommand,\n  ScreenCommand,\n} from '../../domain/entities/automation-command.js';\nimport type { IAutomationExecutor } from '../../domain/use-cases/execute-automation.use-case.js';\nimport { MouseService } from './mouse.service.js';\nimport { ScreenService } from './screen.service.js';\nimport type { MouseAction } from '../../domain/entities/mouse-action.js';\n\n@injectable()\nexport class AutomationService implements IAutomationExecutor {\n  constructor(\n    @inject('MouseService')\n    private readonly mouseService: MouseService,\n    @inject('ScreenService')\n    private readonly screenService: ScreenService,\n  ) {}\n\n  async execute(command: AutomationCommand): Promise<CommandResult> {\n    try {\n      switch (command.type) {\n        case 'mouse':\n          return await this.executeMouseCommand(command as MouseCommand);\n        case 'screen':\n          return await this.executeScreenCommand(command as ScreenCommand);\n        case 'wait':\n          return await command.execute();\n        default:\n          return {\n            success: false,\n            error: `Unknown command type: ${command.type}`,\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred',\n      };\n    }\n  }\n\n  private async executeMouseCommand(command: MouseCommand): Promise<CommandResult> {\n    const { action } = command;\n\n    switch (action.type) {\n      case 'move':\n        if (!action.position) {\n          return { success: false, error: 'Position required for move action' };\n        }\n        await this.mouseService.move({\n          x: action.position.x,\n          y: action.position.y,\n          ...(action.options as any),\n        });\n        return { success: true };\n\n      case 'click':\n        await this.mouseService.click({\n          x: action.position?.x,\n          y: action.position?.y,\n          ...(action.options as any),\n        });\n        return { success: true };\n\n      case 'drag':\n        const dragOptions = action.options as any;\n        if (!action.position || !dragOptions?.to) {\n          return { success: false, error: 'From and to positions required for drag action' };\n        }\n        await this.mouseService.drag({\n          from: action.position,\n          to: dragOptions.to,\n          duration: dragOptions.duration || 1000,\n          smooth: dragOptions.smooth !== undefined ? dragOptions.smooth : true,\n        });\n        return { success: true };\n\n      case 'scroll':\n        const scrollOptions = action.options as any;\n        if (!scrollOptions?.direction || !scrollOptions?.amount) {\n          return { success: false, error: 'Direction and amount required for scroll action' };\n        }\n        await this.mouseService.scroll({\n          direction: scrollOptions.direction,\n          amount: scrollOptions.amount,\n          duration: scrollOptions.duration || 1000,\n          smooth: scrollOptions.smooth !== undefined ? scrollOptions.smooth : true,\n        });\n        return { success: true };\n\n      default:\n        return { success: false, error: `Unknown mouse action: ${action.type}` };\n    }\n  }\n\n  private async executeScreenCommand(command: ScreenCommand): Promise<CommandResult> {\n    switch (command.operation) {\n      case 'capture':\n        const imageData = await this.screenService.capture({\n          region: command.region,\n          format: 'png',\n        });\n        return { success: true, data: { image: imageData } };\n\n      case 'find':\n        if (!command.template) {\n          return { success: false, error: 'Template required for find operation' };\n        }\n        const matches = await this.screenService.findTemplate({\n          template: command.template,\n          region: command.region,\n          confidence: 0.8,\n        });\n        return { success: true, data: { matches } };\n\n      case 'waitFor':\n        if (!command.template) {\n          return { success: false, error: 'Template required for waitFor operation' };\n        }\n        const match = await this.screenService.waitForTemplate(command.template);\n        return { success: true, data: { match } };\n\n      default:\n        return { success: false, error: `Unknown screen operation: ${command.operation}` };\n    }\n  }\n}",
    "processedAt": "2025-07-01T20:20:46.149Z"
  },
  {
    "path": "src/application/dto/clipboard-request.dto.ts",
    "sha": "1e1ec37a66841dd178924e56732258b505019b2c",
    "size": 1022,
    "summary": "Este arquivo define Data Transfer Objects (DTOs) para operações relacionadas ao clipboard, utilizando a biblioteca Zod para validação rigorosa dos dados de entrada. O principal foco é garantir a integridade e conformidade dos dados para operações de copiar, colar e limpar o conteúdo do clipboard, com validações específicas como limite de tamanho para o conteúdo copiado (máximo de 1 MB). O código é estruturado para suportar requisições REST, onde as operações de paste e clear não requerem payload, enquanto a operação de copy valida o conteúdo textual enviado. Essa abordagem assegura robustez e segurança na manipulação do clipboard, facilitando a integração com outras partes do sistema que dependem dessas operações, além de promover a manutenção e escalabilidade do código por meio do uso de schemas fortemente tipados e reutilizáveis.",
    "content": "/**\n * DTOs para requisições relacionadas a operações de clipboard\n * Define schemas de validação usando Zod para garantir integridade dos dados\n */\n\nimport { z } from 'zod';\n\n/**\n * Schema para copiar conteúdo para clipboard\n */\nexport const clipboardCopySchema = z.object({\n  content: z.string()\n    .min(1, 'Content cannot be empty')\n    .refine(\n      (content) => {\n        const sizeBytes = Buffer.byteLength(content, 'utf8');\n        return sizeBytes <= 1048576; // 1 MB\n      },\n      'Content size exceeds maximum of 1 MB'\n    )\n});\n\n/**\n * Schema vazio para operação de paste (GET request)\n */\nexport const clipboardPasteSchema = z.object({});\n\n/**\n * Schema vazio para operação de clear\n */\nexport const clipboardClearSchema = z.object({});\n\n/**\n * Tipos inferidos dos schemas\n */\nexport type ClipboardCopyRequest = z.infer<typeof clipboardCopySchema>;\nexport type ClipboardPasteRequest = z.infer<typeof clipboardPasteSchema>;\nexport type ClipboardClearRequest = z.infer<typeof clipboardClearSchema>;",
    "processedAt": "2025-07-01T20:20:46.957Z"
  },
  {
    "path": "src/application/services/clipboard.service.ts",
    "sha": "e1accb78a058509da95447a2323f97e372fcbdae",
    "size": 2897,
    "summary": "O arquivo implementa um serviço de automação para manipulação da área de transferência (clipboard) em aplicações TypeScript, fornecendo operações assíncronas para copiar, colar e limpar conteúdo. Ele valida o tamanho do conteúdo a ser copiado para garantir que não ultrapasse 1 MB, utiliza a biblioteca clipboardy para interação com o sistema operacional e retorna resultados padronizados com sucesso ou erro, facilitando a integração com outros módulos. O serviço é projetado para ser injetável via tsyringe, promovendo desacoplamento e testabilidade, e trata erros de forma robusta para garantir confiabilidade nas operações de clipboard.",
    "content": "/**\n * Serviço de controle de área de transferência (clipboard)\n * Fornece funcionalidades para copiar e colar conteúdo\n */\n\nimport { injectable } from 'tsyringe';\nimport clipboardy from 'clipboardy';\nimport type { IAutomationService } from '../../domain/interfaces/automation-service.interface.js';\nimport type { CommandResult } from '../../domain/entities/command-result.js';\n\n/**\n * Serviço para automação de clipboard\n */\n@injectable()\nexport class ClipboardService implements IAutomationService {\n  private readonly MAX_CONTENT_SIZE = 1048576; // 1 MB\n\n  /**\n   * Copia conteúdo para a área de transferência\n   * @param content - Conteúdo a ser copiado\n   * @returns Resultado da operação\n   */\n  async copy(content: string): Promise<CommandResult> {\n    try {\n      // Valida tamanho do conteúdo\n      if (!content) {\n        throw new Error('Content cannot be empty');\n      }\n\n      const contentSize = Buffer.byteLength(content, 'utf8');\n      if (contentSize > this.MAX_CONTENT_SIZE) {\n        throw new Error(`Content size ${contentSize} bytes exceeds maximum of ${this.MAX_CONTENT_SIZE} bytes (1 MB)`);\n      }\n\n      // Copia para clipboard\n      await clipboardy.write(content);\n\n      return {\n        success: true,\n        data: {\n          contentLength: content.length,\n          sizeBytes: contentSize\n        }\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      return {\n        success: false,\n        error: `Clipboard copy error: ${message}`\n      };\n    }\n  }\n\n  /**\n   * Cola o conteúdo atual da área de transferência\n   * @returns Resultado da operação com o conteúdo colado\n   */\n  async paste(): Promise<CommandResult> {\n    try {\n      // Lê conteúdo do clipboard\n      const content = await clipboardy.read();\n\n      if (!content) {\n        return {\n          success: true,\n          data: {\n            content: '',\n            isEmpty: true,\n            contentLength: 0\n          }\n        };\n      }\n\n      return {\n        success: true,\n        data: {\n          content,\n          isEmpty: false,\n          contentLength: content.length\n        }\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      return {\n        success: false,\n        error: `Clipboard paste error: ${message}`\n      };\n    }\n  }\n\n  /**\n   * Limpa o conteúdo da área de transferência\n   * @returns Resultado da operação\n   */\n  async clear(): Promise<CommandResult> {\n    try {\n      await clipboardy.write('');\n      \n      return {\n        success: true,\n        data: {\n          cleared: true\n        }\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      return {\n        success: false,\n        error: `Clipboard clear error: ${message}`\n      };\n    }\n  }\n}",
    "processedAt": "2025-07-01T20:20:47.924Z"
  },
  {
    "path": "package.json",
    "sha": "15700239d00445f35fd7c7a42dab2a0e4191ea1b",
    "size": 1648,
    "summary": "O projeto nutjs-rest-api é uma API RESTful que serve como um wrapper para a automação desktop utilizando a biblioteca NutJS. Seu principal objetivo é expor funcionalidades de automação de interface gráfica via endpoints HTTP, facilitando a integração com outros sistemas e a execução remota de comandos de automação. O código gerencia o ciclo de vida da aplicação, incluindo desenvolvimento, build, testes e linting, utilizando TypeScript e Fastify para garantir performance e escalabilidade. A arquitetura modular e o uso de injeção de dependências promovem manutenibilidade e extensibilidade, enquanto a integração com ferramentas como Jest e ESLint assegura qualidade e confiabilidade do código. A API suporta operações de automação complexas, manipulação de clipboard e configuração via variáveis de ambiente, habilitando automações robustas e seguras em ambientes desktop.",
    "content": "{\n  \"name\": \"nutjs-rest-api\",\n  \"version\": \"1.0.0\",\n  \"type\": \"module\",\n  \"description\": \"REST API wrapper for NutJS desktop automation\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"dev\": \"tsx watch src/index.ts\",\n    \"build\": \"tsc -p tsconfig.json\",\n    \"build:prod\": \"tsc -p tsconfig.prod.json\",\n    \"start\": \"node dist/index.js\",\n    \"test\": \"jest\",\n    \"test:unit\": \"jest tests/unit\",\n    \"test:integration\": \"jest tests/integration\",\n    \"test:coverage\": \"jest --coverage\",\n    \"test:api\": \"tsx src/test-endpoint.ts\",\n    \"lint\": \"eslint src/**/*.ts\",\n    \"lint:fix\": \"eslint src/**/*.ts --fix\",\n    \"format\": \"prettier --write src/**/*.ts\",\n    \"format:check\": \"prettier --check src/**/*.ts\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"audit:roadmap\": \"echo 'TODO: Implement roadmap audit script'\",\n    \"clean\": \"rm -rf dist coverage .nyc_output\"\n  },\n  \"dependencies\": {\n    \"@nut-tree-fork/nut-js\": \"^4.2.0\",\n    \"clipboardy\": \"^4.0.0\",\n    \"dotenv\": \"^16.3.1\",\n    \"fastify\": \"^4.24.0\",\n    \"pino\": \"^8.16.0\",\n    \"pino-pretty\": \"^10.3.0\",\n    \"reflect-metadata\": \"^0.2.1\",\n    \"tsyringe\": \"^4.8.0\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"devDependencies\": {\n    \"@types/clipboardy\": \"^1.1.0\",\n    \"@types/eventsource\": \"^1.1.15\",\n    \"@types/jest\": \"^29.5.11\",\n    \"@types/node\": \"^20.10.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.12.0\",\n    \"@typescript-eslint/parser\": \"^6.12.0\",\n    \"eslint\": \"^8.54.0\",\n    \"eslint-config-prettier\": \"^9.0.0\",\n    \"eslint-plugin-prettier\": \"^5.0.1\",\n    \"eventsource\": \"^2.0.2\",\n    \"jest\": \"^29.7.0\",\n    \"prettier\": \"^3.1.0\",\n    \"ts-jest\": \"^29.1.1\",\n    \"tsx\": \"^4.6.0\",\n    \"typescript\": \"^5.3.2\"\n  }\n}\n",
    "processedAt": "2025-07-01T20:20:49.658Z"
  },
  {
    "path": "src/config/keyboard.config.ts",
    "sha": "0cda18b7c0254e4055c35ec7f7145feb363162f2",
    "size": 2007,
    "summary": "Este arquivo define configurações imutáveis para funcionalidades de teclado, permitindo a personalização via variáveis de ambiente para parâmetros como modo de digitação, tamanho máximo de texto, delays por caractere e tamanho de lote para processamento. Inclui uma função de validação que assegura que os valores configurados estejam dentro de limites seguros e aceitáveis, prevenindo erros de configuração que possam impactar a performance ou comportamento do sistema. O código integra-se a um sistema maior que manipula entrada de texto, habilitando controle preciso sobre o comportamento do teclado virtual ou automatizado, com suporte a logs detalhados para depuração, garantindo robustez e flexibilidade operacional.",
    "content": "/**\n * Configurações para funcionalidades de teclado\n * Valores podem ser sobrescritos via variáveis de ambiente\n */\n\nimport { config } from 'dotenv';\n\n// Carrega variáveis de ambiente\nconfig();\n\n/**\n * Configurações imutáveis para keyboard\n */\nexport const KeyboardConfig = {\n  /**\n   * Modo padrão de digitação quando não especificado\n   */\n  defaultMode: process.env.[REDACTED] || 'instant',\n\n  /**\n   * Tamanho máximo de texto permitido (caracteres)\n   */\n  maxTextLength: parseInt(process.env.[REDACTED] || '10000', 10),\n\n  /**\n   * Delay padrão por caractere em milissegundos\n   */\n  defaultDelayPerChar: parseInt(process.env.[REDACTED] || '0', 10),\n\n  /**\n   * Delay máximo permitido em milissegundos (5 minutos)\n   */\n  maxDelay: parseInt(process.env.KEYBOARD_MAX_DELAY || '300000', 10),\n\n  /**\n   * Tamanho do lote para processamento de caracteres\n   */\n  batchSize: parseInt(process.env.KEYBOARD_BATCH_SIZE || '50', 10),\n\n  /**\n   * Habilita logs detalhados para debug\n   */\n  debugMode: process.env.KEYBOARD_DEBUG === 'true',\n} as const;\n\n/**\n * Valida as configurações\n */\nexport function validateKeyboardConfig(): void {\n  if (KeyboardConfig.maxTextLength < 1 || KeyboardConfig.maxTextLength > 100000) {\n    throw new Error('[REDACTED] must be between 1 and 100000');\n  }\n\n  if (KeyboardConfig.defaultDelayPerChar < 0) {\n    throw new Error('[REDACTED] must be non-negative');\n  }\n\n  if (KeyboardConfig.maxDelay < 0 || KeyboardConfig.maxDelay > 3600000) {\n    throw new Error('KEYBOARD_MAX_DELAY must be between 0 and 3600000 (1 hour)');\n  }\n\n  if (KeyboardConfig.batchSize < 1 || KeyboardConfig.batchSize > 1000) {\n    throw new Error('KEYBOARD_BATCH_SIZE must be between 1 and 1000');\n  }\n\n  const validModes = ['instant', 'perChar', 'total'];\n  if (!validModes.includes(KeyboardConfig.defaultMode)) {\n    throw new Error(`[REDACTED] must be one of: ${validModes.join(', ')}`);\n  }\n}\n",
    "processedAt": "2025-07-01T20:20:50.431Z"
  },
  {
    "path": "src/application/services/keyboard.service.ts",
    "sha": "350287036eeded8d0be069f0acf5491a45f97749",
    "size": 6417,
    "summary": "Este arquivo implementa um serviço de automação de teclado que permite a digitação programada de texto com controle flexível de timing, suportando modos instantâneo, por caractere com delay e por tempo total distribuído. Ele abstrai a interação com o hardware via um adaptador de teclado, garantindo a sanitização do texto para evitar caracteres de controle perigosos e validações rigorosas de tamanho e parâmetros de tempo. O serviço também oferece funcionalidades para pressionar teclas isoladas e executar combinações de teclas, com tratamento robusto de erros e retorno padronizado de resultados, facilitando sua integração em sistemas maiores de automação e testes automatizados.",
    "content": "/**\n * Serviço de automação de teclado com estratégias de timing\n * Fornece funcionalidades para digitação com controle de velocidade\n */\n\nimport { inject, injectable } from 'tsyringe';\nimport type { IAutomationService } from '../../domain/interfaces/automation-service.interface.js';\nimport type { CommandResult } from '../../domain/entities/command-result.js';\n\n/**\n * Interface para o adaptador de teclado\n */\nexport interface IKeyboardAdapter {\n  type(text: string): Promise<void>;\n  pressKey(key: string): Promise<void>;\n  releaseKey(key: string): Promise<void>;\n  combination(keys: string[]): Promise<void>;\n  delay(ms: number): Promise<void>;\n}\n\n/**\n * Interface para estratégias de digitação\n */\ninterface ITypeStrategy {\n  type(text: string, adapter: IKeyboardAdapter): Promise<void>;\n}\n\n/**\n * Estratégia de digitação instantânea\n */\nclass InstantTypeStrategy implements ITypeStrategy {\n  async type(text: string, adapter: IKeyboardAdapter): Promise<void> {\n    await adapter.type(text);\n  }\n}\n\n/**\n * Estratégia de digitação com delay por caractere\n */\nclass PerCharTypeStrategy implements ITypeStrategy {\n  constructor(private delayPerChar: number) {}\n\n  async type(text: string, adapter: IKeyboardAdapter): Promise<void> {\n    const chars = Array.from(text); // Suporta Unicode corretamente\n    const batchSize = 50; // Processa em lotes para melhor performance\n\n    for (let i = 0; i < chars.length; i += batchSize) {\n      const batch = chars.slice(i, i + batchSize);\n      \n      for (const char of batch) {\n        await adapter.type(char);\n        if (this.delayPerChar > 0) {\n          await adapter.delay(this.delayPerChar);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Estratégia de digitação com tempo total\n */\nclass TotalTimeTypeStrategy implements ITypeStrategy {\n  constructor(private totalTime: number) {}\n\n  async type(text: string, adapter: IKeyboardAdapter): Promise<void> {\n    const chars = Array.from(text);\n    \n    if (chars.length === 0) {\n      return;\n    }\n\n    if (chars.length === 1) {\n      await adapter.type(text);\n      return;\n    }\n\n    // Calcula delay uniforme entre caracteres\n    const delayPerChar = Math.floor(this.totalTime / chars.length);\n\n    for (const char of chars) {\n      await adapter.type(char);\n      if (delayPerChar > 0) {\n        await adapter.delay(delayPerChar);\n      }\n    }\n  }\n}\n\n/**\n * Opções de configuração para digitação\n */\nexport interface TypeOptions {\n  text: string;\n  mode?: 'instant' | 'perChar' | 'total';\n  value?: number;\n}\n\n/**\n * Serviço para automação de teclado\n */\n@injectable()\nexport class KeyboardService implements IAutomationService {\n  constructor(\n    @inject('IKeyboardAdapter') private keyboardAdapter: IKeyboardAdapter\n  ) {}\n\n  /**\n   * Digita texto com opções de timing\n   * @param options - Opções de digitação incluindo texto e modo\n   * @returns Resultado da operação\n   */\n  async type(options: TypeOptions): Promise<CommandResult> {\n    try {\n      // Sanitiza o texto removendo caracteres de controle perigosos\n      const sanitizedText = this.sanitizeText(options.text);\n      \n      // Valida limites\n      if (sanitizedText.length === 0) {\n        throw new Error('Text cannot be empty after sanitization');\n      }\n\n      if (sanitizedText.length > 10000) {\n        throw new Error('Text exceeds maximum length of 10000 characters');\n      }\n\n      // Seleciona estratégia baseada no modo\n      const strategy = this.createStrategy(options);\n      \n      // Executa digitação\n      await strategy.type(sanitizedText, this.keyboardAdapter);\n\n      return {\n        success: true,\n        data: {\n          textLength: sanitizedText.length,\n          mode: options.mode || 'instant',\n          timing: options.value\n        }\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      return {\n        success: false,\n        error: `Keyboard type error: ${message}`\n      };\n    }\n  }\n\n  /**\n   * Pressiona uma tecla específica\n   * @param key - Nome da tecla a ser pressionada\n   * @returns Resultado da operação\n   */\n  async pressKey(key: string): Promise<CommandResult> {\n    try {\n      await this.keyboardAdapter.pressKey(key);\n      return {\n        success: true,\n        data: { key }\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      return {\n        success: false,\n        error: `Keyboard press key error: ${message}`\n      };\n    }\n  }\n\n  /**\n   * Executa combinação de teclas\n   * @param keys - Array de teclas para combinação\n   * @returns Resultado da operação\n   */\n  async combination(keys: string[]): Promise<CommandResult> {\n    try {\n      if (keys.length === 0) {\n        throw new Error('Key combination requires at least one key');\n      }\n\n      if (keys.length > 5) {\n        throw new Error('Key combination supports maximum 5 keys');\n      }\n\n      await this.keyboardAdapter.combination(keys);\n      return {\n        success: true,\n        data: { combination: keys.join('+') }\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      return {\n        success: false,\n        error: `Keyboard combination error: ${message}`\n      };\n    }\n  }\n\n  /**\n   * Cria estratégia de digitação baseada nas opções\n   */\n  private createStrategy(options: TypeOptions): ITypeStrategy {\n    const mode = options.mode || 'instant';\n    const value = options.value || 0;\n\n    // Valida valor máximo\n    if (value > 300000) { // 5 minutos\n      throw new Error('Timing value exceeds maximum of 300000ms (5 minutes)');\n    }\n\n    switch (mode) {\n      case 'perChar':\n        if (value < 0) {\n          throw new Error('Per-character delay must be non-negative');\n        }\n        return new PerCharTypeStrategy(value);\n      \n      case 'total':\n        if (value < 0) {\n          throw new Error('Total time must be non-negative');\n        }\n        return new TotalTimeTypeStrategy(value);\n      \n      case 'instant':\n      default:\n        return new InstantTypeStrategy();\n    }\n  }\n\n  /**\n   * Sanitiza texto removendo caracteres de controle perigosos\n   */\n  private sanitizeText(text: string): string {\n    // Remove caracteres de controle (0x00-0x1F) exceto \\n (0x0A) e \\t (0x09)\n    return text.replace(/[\\x00-\\x08\\x0B-\\x0C\\x0E-\\x1F]/g, '');\n  }\n}",
    "processedAt": "2025-07-01T20:20:50.618Z"
  },
  {
    "path": "src/config/mouse.config.ts",
    "sha": "3051823ed63ce1b0c779762b913f8a78e3251798",
    "size": 925,
    "summary": "Este arquivo define uma configuração padrão para operações relacionadas ao mouse, centralizando parâmetros essenciais para controlar o comportamento de ações como movimentos e cliques. Ele extrai valores de variáveis de ambiente para permitir customização dinâmica, garantindo flexibilidade na duração mínima e máxima das ações, suavização do movimento, taxa de amostragem para interpolação e intervalos de streaming. A estrutura é imutável, promovendo segurança e previsibilidade no uso dessas configurações, que são fundamentais para módulos que dependem de interações precisas e controladas do mouse em aplicações que demandam alta responsividade e controle fino de input.",
    "content": "/**\n * Configuração padrão para operações do mouse\n */\nexport const MouseDefaults = {\n  /** Duração mínima permitida para ações do mouse em ms */\n  minDuration: parseInt(process.env.MOUSE_MIN_DUR || '100', 10),\n\n  /** Duração máxima permitida para ações do mouse em ms */\n  maxDuration: parseInt(process.env.MOUSE_MAX_DUR || '5000', 10),\n\n  /** Valor padrão para movimento suave */\n  defaultSmooth: process.env.[REDACTED] === 'true' || false,\n\n  /** Taxa de amostragem para interpolação suave (fps) */\n  sampleRate: parseInt(process.env.MOUSE_SAMPLE_RATE || '30', 10),\n\n  /** Intervalo padrão em ms para streaming de posição */\n  streamInterval: parseInt(process.env.[REDACTED] || '100', 10),\n\n  /** Duração padrão para movimentos em ms */\n  defaultDuration: parseInt(process.env.[REDACTED] || '1000', 10),\n} as const;\n\nexport type MouseConfig = typeof MouseDefaults;\n",
    "processedAt": "2025-07-01T20:21:18.064Z"
  },
  {
    "path": "src/domain/entities/command-result.ts",
    "sha": "8bb2d29a310c1e2595a52c92a660bc0f0c268cef",
    "size": 379,
    "summary": "Este arquivo define uma interface TypeScript chamada CommandResult, que padroniza o formato de resposta para a execução de comandos em serviços de automação. Seu propósito principal é encapsular o resultado de operações, indicando sucesso ou falha, e fornecendo dados ou mensagens de erro conforme apropriado. Essa estrutura simples e genérica facilita a interoperabilidade entre módulos, garantindo um contrato claro para o tratamento de respostas e erros em fluxos automatizados, promovendo consistência e robustez na comunicação entre componentes do sistema.",
    "content": "/**\n * Resultado padrão para execução de comandos\n * Utilizado por todos os serviços de automação\n */\n\nexport interface CommandResult {\n  /**\n   * Indica se a operação foi bem-sucedida\n   */\n  success: boolean;\n  \n  /**\n   * Dados retornados pela operação (quando bem-sucedida)\n   */\n  data?: any;\n  \n  /**\n   * Mensagem de erro (quando falha)\n   */\n  error?: string;\n}",
    "processedAt": "2025-07-01T20:21:19.076Z"
  },
  {
    "path": "src/infrastructure/adapters/nutjs/nutjs-keyboard.adapter.ts",
    "sha": "82a62dedf727bcd376a9c23d396df93f403568a0",
    "size": 5237,
    "summary": "Este arquivo implementa um adaptador de teclado utilizando a biblioteca NutJS, fornecendo uma interface abstrata para operações de teclado que incluem digitação de texto, pressionamento e liberação de teclas individuais, além de combinações de teclas. O adaptador encapsula a complexidade da biblioteca NutJS, mapeando strings representativas de teclas para constantes específicas, garantindo suporte a teclas comuns e combinações como Ctrl+C e Cmd+V. Ele também trata erros de forma robusta, lançando exceções detalhadas em caso de falhas, e oferece uma função de delay para pausas controladas, facilitando a integração com sistemas que necessitam de automação de entrada via teclado. Essa implementação é injetável via tsyringe, permitindo fácil integração em arquiteturas baseadas em injeção de dependência e promovendo desacoplamento e testabilidade.",
    "content": "/**\n * Adaptador para controle de teclado usando NutJS\n * Fornece interface abstrata para operações de teclado independente da implementação\n */\n\nimport { keyboard, Key } from '@nut-tree-fork/nut-js';\nimport { injectable } from 'tsyringe';\nimport type { IKeyboardAdapter } from '../../../application/services/keyboard.service.js';\n\n/**\n * Implementação do adaptador de teclado usando NutJS\n * Encapsula a biblioteca NutJS para operações de teclado\n */\n@injectable()\nexport class NutJSKeyboardAdapter implements IKeyboardAdapter {\n  /**\n   * Digita um texto caractere por caractere\n   * @param text - O texto a ser digitado\n   * @throws {Error} Se a operação de digitação falhar\n   */\n  async type(text: string): Promise<void> {\n    try {\n      await keyboard.type(text);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to type text: ${message}`);\n    }\n  }\n\n  /**\n   * Pressiona uma tecla específica\n   * @param key - A tecla a ser pressionada (e.g., 'Enter', 'Tab')\n   * @throws {Error} Se a tecla não for suportada ou a operação falhar\n   */\n  async pressKey(key: string): Promise<void> {\n    try {\n      // Mapeamento de strings para teclas do NutJS\n      const keyMap: Record<string, Key> = {\n        'enter': Key.Enter,\n        'tab': Key.Tab,\n        'escape': Key.Escape,\n        'space': Key.Space,\n        'backspace': Key.Backspace,\n        'delete': Key.Delete,\n        'up': Key.Up,\n        'down': Key.Down,\n        'left': Key.Left,\n        'right': Key.Right,\n        'home': Key.Home,\n        'end': Key.End,\n        'pageup': Key.PageUp,\n        'pagedown': Key.PageDown,\n        'f1': Key.F1,\n        'f2': Key.F2,\n        'f3': Key.F3,\n        'f4': Key.F4,\n        'f5': Key.F5,\n        'f6': Key.F6,\n        'f7': Key.F7,\n        'f8': Key.F8,\n        'f9': Key.F9,\n        'f10': Key.F10,\n        'f11': Key.F11,\n        'f12': Key.F12\n      };\n\n      const nutKey = keyMap[key.toLowerCase()];\n      if (!nutKey) {\n        throw new Error(`Unsupported key: ${key}`);\n      }\n\n      await keyboard.pressKey(nutKey);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to press key '${key}': ${message}`);\n    }\n  }\n\n  /**\n   * Libera uma tecla específica (após pressKey)\n   * @param key - A tecla a ser liberada\n   * @throws {Error} Se a tecla não for suportada ou a operação falhar\n   */\n  async releaseKey(key: string): Promise<void> {\n    try {\n      const keyMap: Record<string, Key> = {\n        'enter': Key.Enter,\n        'tab': Key.Tab,\n        'escape': Key.Escape,\n        'space': Key.Space,\n        'backspace': Key.Backspace,\n        'delete': Key.Delete,\n        'up': Key.Up,\n        'down': Key.Down,\n        'left': Key.Left,\n        'right': Key.Right,\n        'home': Key.Home,\n        'end': Key.End,\n        'pageup': Key.PageUp,\n        'pagedown': Key.PageDown,\n        'f1': Key.F1,\n        'f2': Key.F2,\n        'f3': Key.F3,\n        'f4': Key.F4,\n        'f5': Key.F5,\n        'f6': Key.F6,\n        'f7': Key.F7,\n        'f8': Key.F8,\n        'f9': Key.F9,\n        'f10': Key.F10,\n        'f11': Key.F11,\n        'f12': Key.F12\n      };\n\n      const nutKey = keyMap[key.toLowerCase()];\n      if (!nutKey) {\n        throw new Error(`Unsupported key: ${key}`);\n      }\n\n      await keyboard.releaseKey(nutKey);\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to release key '${key}': ${message}`);\n    }\n  }\n\n  /**\n   * Realiza combinação de teclas (e.g., Ctrl+C, Cmd+V)\n   * @param keys - Array de teclas para pressionar simultaneamente\n   * @throws {Error} Se alguma tecla não for suportada ou a operação falhar\n   */\n  async combination(keys: string[]): Promise<void> {\n    try {\n      const keyMap: Record<string, Key> = {\n        'ctrl': Key.LeftControl,\n        'control': Key.LeftControl,\n        'alt': Key.LeftAlt,\n        'shift': Key.LeftShift,\n        'cmd': Key.LeftSuper,\n        'command': Key.LeftSuper,\n        'meta': Key.LeftSuper,\n        'win': Key.LeftSuper,\n        'a': Key.A,\n        'c': Key.C,\n        'v': Key.V,\n        'x': Key.X,\n        'z': Key.Z,\n        'y': Key.Y\n      };\n\n      const nutKeys = keys.map(key => {\n        const nutKey = keyMap[key.toLowerCase()];\n        if (!nutKey) {\n          throw new Error(`Unsupported key in combination: ${key}`);\n        }\n        return nutKey;\n      });\n\n      // Pressiona todas as teclas em ordem\n      for (const nutKey of nutKeys) {\n        await keyboard.pressKey(nutKey);\n      }\n\n      // Libera todas as teclas em ordem reversa\n      for (let i = nutKeys.length - 1; i >= 0; i--) {\n        await keyboard.releaseKey(nutKeys[i]);\n      }\n    } catch (error) {\n      const message = error instanceof Error ? error.message : 'Unknown error';\n      throw new Error(`Failed to perform key combination: ${message}`);\n    }\n  }\n\n  /**\n   * Aguarda um período de tempo\n   * @param ms - Tempo em milissegundos para aguardar\n   */\n  async delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}",
    "processedAt": "2025-07-01T20:21:23.813Z"
  },
  {
    "path": "src/interface/schemas/keyboard.schemas.ts",
    "sha": "597336646fefcd2fef48d0c421bb22edd8155e08",
    "size": 1873,
    "summary": "Este arquivo define JSON Schemas compatíveis com o Draft 7 para validação de requisições relacionadas a operações de teclado em um servidor Fastify. Ele especifica três schemas distintos para endpoints que lidam com digitação de texto, pressionamento de tecla única e combinação de teclas, garantindo que os dados recebidos estejam estruturados e validados conforme regras claras, como tipos, tamanhos e valores permitidos. A funcionalidade principal é assegurar a integridade e conformidade dos dados de entrada para ações de teclado automatizadas, facilitando a integração segura e previsível com sistemas que executam comandos de teclado programaticamente.",
    "content": "/**\n * JSON Schemas para validação de requisições de teclado no Fastify\n * Compatível com JSON Schema Draft 7\n */\n\nimport type { JSONSchema7 } from 'json-schema';\n\n/**\n * Schema para endpoint de digitação de texto\n */\nexport const keyboardTypeJsonSchema: JSONSchema7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {\n    text: {\n      type: 'string',\n      minLength: 1,\n      maxLength: 10000,\n      description: 'Text to be typed'\n    },\n    mode: {\n      type: 'string',\n      enum: ['instant', 'perChar', 'total'],\n      default: 'instant',\n      description: 'Typing mode: instant (immediate), perChar (delay per character), total (total duration)'\n    },\n    value: {\n      type: 'integer',\n      minimum: 0,\n      maximum: 300000,\n      description: 'Time value in milliseconds. For perChar mode: delay between each character. For total mode: total duration for typing'\n    }\n  },\n  required: ['text'],\n  additionalProperties: false\n};\n\n/**\n * Schema para endpoint de pressionar tecla\n */\nexport const keyboardPressKeyJsonSchema: JSONSchema7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {\n    key: {\n      type: 'string',\n      minLength: 1,\n      description: 'Key to press (e.g., enter, tab, escape, f1-f12)'\n    }\n  },\n  required: ['key'],\n  additionalProperties: false\n};\n\n/**\n * Schema para endpoint de combinação de teclas\n */\nexport const keyboardCombinationJsonSchema: JSONSchema7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {\n    keys: {\n      type: 'array',\n      items: {\n        type: 'string',\n        minLength: 1\n      },\n      minItems: 1,\n      maxItems: 5,\n      description: 'Array of keys for combination (e.g., [\"ctrl\", \"c\"] for Ctrl+C)'\n    }\n  },\n  required: ['keys'],\n  additionalProperties: false\n};",
    "processedAt": "2025-07-01T20:21:26.485Z"
  },
  {
    "path": "src/interface/schemas/clipboard.schemas.ts",
    "sha": "acd518c955d3999fc8e7ae684b7c6cb3d3fc4d18",
    "size": 1033,
    "summary": "Este arquivo define JSON Schemas compatíveis com JSON Schema Draft 7 para validação de requisições relacionadas a operações de clipboard em um servidor Fastify. Ele especifica um schema para a operação de copiar conteúdo para o clipboard, exigindo uma string não vazia com limite implícito de tamanho, e schemas vazios para operações de colar e limpar o clipboard, garantindo que não sejam aceitas propriedades adicionais. O foco principal é garantir a integridade e conformidade dos dados recebidos nas requisições HTTP, facilitando a validação automática e segura dos payloads, evitando erros e comportamentos inesperados na manipulação do clipboard via API.",
    "content": "/**\n * JSON Schemas para validação de requisições de clipboard no Fastify\n * Compatível com JSON Schema Draft 7\n */\n\nimport type { JSONSchema7 } from 'json-schema';\n\n/**\n * Schema para endpoint de copiar para clipboard\n */\nexport const clipboardCopyJsonSchema: JSONSchema7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {\n    content: {\n      type: 'string',\n      minLength: 1,\n      description: 'Content to copy to clipboard (max 1 MB)'\n    }\n  },\n  required: ['content'],\n  additionalProperties: false\n};\n\n/**\n * Schema vazio para endpoint de colar (GET request)\n */\nexport const clipboardPasteJsonSchema: JSONSchema7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {},\n  additionalProperties: false\n};\n\n/**\n * Schema vazio para endpoint de limpar clipboard\n */\nexport const clipboardClearJsonSchema: JSONSchema7 = {\n  $schema: 'http://json-schema.org/draft-07/schema#',\n  type: 'object',\n  properties: {},\n  additionalProperties: false\n};",
    "processedAt": "2025-07-01T20:21:29.310Z"
  },
  {
    "path": "src/domain/interfaces/automation-service.interface.ts",
    "sha": "61cdf8f8af167f8d2ba501f352babb41497db209",
    "size": 427,
    "summary": "Este arquivo define uma interface base para serviços de automação, estabelecendo um contrato comum para todos os serviços que executam comandos automatizados dentro do sistema. Embora a interface não especifique métodos concretos, ela funciona como uma marcação para padronizar e identificar serviços de automação, facilitando a integração e extensão futura. Essa abordagem modular permite que diferentes implementações especializadas possam ser desenvolvidas mantendo uma estrutura consistente, promovendo escalabilidade e manutenção simplificada no contexto de automação de processos.",
    "content": "/**\n * Interface base para serviços de automação\n * Define contrato comum para todos os serviços que executam comandos de automação\n */\n\nimport type { CommandResult } from '../entities/command-result.js';\n\n/**\n * Interface padrão para serviços de automação\n */\nexport interface IAutomationService {\n  // Interface marcadora para serviços de automação\n  // Cada serviço específico define seus próprios métodos\n}",
    "processedAt": "2025-07-01T20:21:29.846Z"
  },
  {
    "path": "src/interface/controllers/keyboard.controller.ts",
    "sha": "48d5439be6635edce65f1dd5faf1a3beaf452a5c",
    "size": 10330,
    "summary": "Este arquivo implementa um controller RESTful para operações de automação relacionadas a teclado e clipboard, permitindo a interação programática com entrada de texto, pressionamento de teclas, combinações de teclas e manipulação da área de transferência. Utilizando Fastify como framework HTTP e injeção de dependências via tsyringe, o controller expõe endpoints que recebem requisições validadas por schemas JSON, delegando a execução das ações para serviços especializados. O comportamento central envolve receber comandos estruturados, executar ações assíncronas nos serviços de teclado e clipboard, e retornar respostas padronizadas com informações sobre o sucesso da operação, dados relevantes e mensagens de erro, garantindo robustez com tratamento de exceções e logging detalhado. Essa arquitetura modular e orientada a serviços facilita a integração com sistemas maiores que demandem automação de entrada e manipulação de clipboard, promovendo reutilização, testabilidade e manutenção simplificada.",
    "content": "/**\n * Controller para operações de teclado e clipboard\n * Expõe endpoints REST para automação de entrada de texto e área de transferência\n */\n\nimport type { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';\nimport { inject, injectable, container } from 'tsyringe';\nimport { KeyboardService } from '../../application/services/keyboard.service.js';\nimport { ClipboardService } from '../../application/services/clipboard.service.js';\nimport { \n  keyboardTypeSchema,\n  keyboardPressKeySchema,\n  keyboardCombinationSchema\n} from '../../application/dto/keyboard-request.dto.js';\nimport type {\n  KeyboardTypeRequest,\n  KeyboardPressKeyRequest,\n  KeyboardCombinationRequest\n} from '../../application/dto/keyboard-request.dto.js';\nimport {\n  clipboardCopySchema\n} from '../../application/dto/clipboard-request.dto.js';\nimport type {\n  ClipboardCopyRequest\n} from '../../application/dto/clipboard-request.dto.js';\nimport {\n  keyboardTypeJsonSchema,\n  keyboardPressKeyJsonSchema,\n  keyboardCombinationJsonSchema\n} from '../schemas/keyboard.schemas.js';\nimport {\n  clipboardCopyJsonSchema,\n  clipboardPasteJsonSchema,\n  clipboardClearJsonSchema\n} from '../schemas/clipboard.schemas.js';\nimport { validateRequest } from '../middleware/validation.middleware.js';\nimport { environment } from '../../config/environment.js';\n\n/**\n * Controller responsável pelas operações de teclado e clipboard\n */\n@injectable()\nexport class KeyboardController {\n  private logger: any;\n\n  constructor(\n    @inject('KeyboardService') private keyboardService: KeyboardService,\n    @inject('ClipboardService') private clipboardService: ClipboardService\n  ) {}\n\n  /**\n   * Constrói e registra as rotas do controller\n   */\n  static buildRoutes(fastify: FastifyInstance, _opts: any, done: () => void): void {\n    const controller = new KeyboardController(\n      container.resolve<KeyboardService>('KeyboardService'),\n      container.resolve<ClipboardService>('ClipboardService')\n    );\n    controller.logger = fastify.log;\n    controller.registerRoutes(fastify);\n    done();\n  }\n\n  /**\n   * Registra todas as rotas do controller\n   */\n  private registerRoutes(fastify: FastifyInstance): void {\n    // Rotas de teclado\n    fastify.post('/api/v1/keyboard/type', {\n      schema: {\n        body: keyboardTypeJsonSchema,\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              success: { type: 'boolean' },\n              data: {\n                type: 'object',\n                properties: {\n                  textLength: { type: 'integer' },\n                  mode: { type: 'string' },\n                  timing: { type: 'integer' }\n                }\n              },\n              error: { type: 'string' }\n            }\n          }\n        }\n      },\n      preHandler: validateRequest(keyboardTypeSchema)\n    }, this.type.bind(this));\n\n    fastify.post('/api/v1/keyboard/press', {\n      schema: {\n        body: keyboardPressKeyJsonSchema,\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              success: { type: 'boolean' },\n              data: {\n                type: 'object',\n                properties: {\n                  key: { type: 'string' }\n                }\n              },\n              error: { type: 'string' }\n            }\n          }\n        }\n      },\n      preHandler: validateRequest(keyboardPressKeySchema)\n    }, this.pressKey.bind(this));\n\n    fastify.post('/api/v1/keyboard/combination', {\n      schema: {\n        body: keyboardCombinationJsonSchema,\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              success: { type: 'boolean' },\n              data: {\n                type: 'object',\n                properties: {\n                  combination: { type: 'string' }\n                }\n              },\n              error: { type: 'string' }\n            }\n          }\n        }\n      },\n      preHandler: validateRequest(keyboardCombinationSchema)\n    }, this.combination.bind(this));\n\n    // Rotas de clipboard\n    fastify.post('/api/v1/clipboard/copy', {\n      schema: {\n        body: clipboardCopyJsonSchema,\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              success: { type: 'boolean' },\n              data: {\n                type: 'object',\n                properties: {\n                  contentLength: { type: 'integer' },\n                  sizeBytes: { type: 'integer' }\n                }\n              },\n              error: { type: 'string' }\n            }\n          }\n        }\n      },\n      preHandler: validateRequest(clipboardCopySchema)\n    }, this.clipboardCopy.bind(this));\n\n    fastify.get('/api/v1/clipboard/paste', {\n      schema: {\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              success: { type: 'boolean' },\n              data: {\n                type: 'object',\n                properties: {\n                  content: { type: 'string' },\n                  isEmpty: { type: 'boolean' },\n                  contentLength: { type: 'integer' }\n                }\n              },\n              error: { type: 'string' }\n            }\n          }\n        }\n      }\n    }, this.clipboardPaste.bind(this));\n\n    fastify.post('/api/v1/clipboard/clear', {\n      schema: {\n        body: clipboardClearJsonSchema,\n        response: {\n          200: {\n            type: 'object',\n            properties: {\n              success: { type: 'boolean' },\n              data: {\n                type: 'object',\n                properties: {\n                  cleared: { type: 'boolean' }\n                }\n              },\n              error: { type: 'string' }\n            }\n          }\n        }\n      }\n    }, this.clipboardClear.bind(this));\n  }\n\n  /**\n   * Digita texto com opções de timing\n   */\n  private async type(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      const body = request.body as KeyboardTypeRequest;\n      this.logger.info({ \n        mode: body.mode, \n        textLength: body.text.length,\n        value: body.value \n      }, 'Keyboard type request');\n\n      const result = await this.keyboardService.type(body);\n      \n      if (!result.success) {\n        this.logger.error({ error: result.error }, 'Keyboard type failed');\n      }\n\n      reply.code(200).send(result);\n    } catch (error) {\n      this.logger.error({ error }, 'Unexpected error in keyboard type');\n      reply.code(500).send({\n        success: false,\n        error: 'Internal server error during keyboard type operation'\n      });\n    }\n  }\n\n  /**\n   * Pressiona uma tecla específica\n   */\n  private async pressKey(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      const body = request.body as KeyboardPressKeyRequest;\n      this.logger.info({ key: body.key }, 'Keyboard press key request');\n\n      const result = await this.keyboardService.pressKey(body.key);\n      \n      if (!result.success) {\n        this.logger.error({ error: result.error }, 'Keyboard press key failed');\n      }\n\n      reply.code(200).send(result);\n    } catch (error) {\n      this.logger.error({ error }, 'Unexpected error in keyboard press key');\n      reply.code(500).send({\n        success: false,\n        error: 'Internal server error during keyboard press key operation'\n      });\n    }\n  }\n\n  /**\n   * Executa combinação de teclas\n   */\n  private async combination(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      const body = request.body as KeyboardCombinationRequest;\n      this.logger.info({ keys: body.keys }, 'Keyboard combination request');\n\n      const result = await this.keyboardService.combination(body.keys);\n      \n      if (!result.success) {\n        this.logger.error({ error: result.error }, 'Keyboard combination failed');\n      }\n\n      reply.code(200).send(result);\n    } catch (error) {\n      this.logger.error({ error }, 'Unexpected error in keyboard combination');\n      reply.code(500).send({\n        success: false,\n        error: 'Internal server error during keyboard combination operation'\n      });\n    }\n  }\n\n  /**\n   * Copia conteúdo para clipboard\n   */\n  private async clipboardCopy(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      const body = request.body as ClipboardCopyRequest;\n      this.logger.info({ contentLength: body.content.length }, 'Clipboard copy request');\n\n      const result = await this.clipboardService.copy(body.content);\n      \n      if (!result.success) {\n        this.logger.error({ error: result.error }, 'Clipboard copy failed');\n      }\n\n      reply.code(200).send(result);\n    } catch (error) {\n      this.logger.error({ error }, 'Unexpected error in clipboard copy');\n      reply.code(500).send({\n        success: false,\n        error: 'Internal server error during clipboard copy operation'\n      });\n    }\n  }\n\n  /**\n   * Cola conteúdo do clipboard\n   */\n  private async clipboardPaste(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      this.logger.info('Clipboard paste request');\n\n      const result = await this.clipboardService.paste();\n      \n      if (!result.success) {\n        this.logger.error({ error: result.error }, 'Clipboard paste failed');\n      }\n\n      reply.code(200).send(result);\n    } catch (error) {\n      this.logger.error({ error }, 'Unexpected error in clipboard paste');\n      reply.code(500).send({\n        success: false,\n        error: 'Internal server error during clipboard paste operation'\n      });\n    }\n  }\n\n  /**\n   * Limpa o clipboard\n   */\n  private async clipboardClear(\n    request: FastifyRequest,\n    reply: FastifyReply\n  ): Promise<void> {\n    try {\n      this.logger.info('Clipboard clear request');\n\n      const result = await this.clipboardService.clear();\n      \n      if (!result.success) {\n        this.logger.error({ error: result.error }, 'Clipboard clear failed');\n      }\n\n      reply.code(200).send(result);\n    } catch (error) {\n      this.logger.error({ error }, 'Unexpected error in clipboard clear');\n      reply.code(500).send({\n        success: false,\n        error: 'Internal server error during clipboard clear operation'\n      });\n    }\n  }\n}",
    "processedAt": "2025-07-01T20:21:36.129Z"
  },
  {
    "path": "src/routes/automation.routes.ts",
    "sha": "6df2d633fa6432e02b024cdbbdc3a9f1424e5a1c",
    "size": 548,
    "summary": "Este arquivo define um conjunto de rotas assíncronas para um servidor Fastify, focado em automação e controle de teclado. Ele encapsula a criação e registro de rotas específicas por meio de controladores dedicados, promovendo modularidade e separação de responsabilidades. A funcionalidade principal é expor endpoints que permitem interações automatizadas e manipulação de eventos de teclado, integrando-se de forma transparente ao servidor principal e facilitando a extensão futura do sistema.",
    "content": "import type { FastifyPluginAsync } from 'fastify';\nimport { AutomationController } from '../interface/controllers/automation.controller.js';\nimport { KeyboardController } from '../interface/controllers/keyboard.controller.js';\n\nexport const automationRoutes: FastifyPluginAsync = async (server) => {\n  const controller = new AutomationController();\n  controller.registerRoutes(server);\n\n  // Registra rotas de keyboard e clipboard\n  await server.register((fastify, opts, done) => {\n    KeyboardController.buildRoutes(fastify, opts, done);\n  });\n};\n",
    "processedAt": "2025-07-01T20:21:36.795Z"
  },
  {
    "path": "tsconfig.json",
    "sha": "2fd95f9be816a90c6071eb0721cb0c050061cc07",
    "size": 673,
    "summary": "Este arquivo de configuração TypeScript (tsconfig.json) define as opções do compilador para um projeto moderno que utiliza recursos avançados do ECMAScript 2022 e módulos ESNext, garantindo interoperabilidade com módulos CommonJS e suporte a decoradores experimentais. Ele configura um ambiente estrito de tipagem com verificações rigorosas para evitar erros comuns, além de habilitar geração de mapas de fonte e declarações de tipos para facilitar o desenvolvimento e manutenção. A estrutura de pastas é organizada para separar código fonte e saída compilada, excluindo testes e dependências externas, o que contribui para um build limpo e eficiente, integrando-se facilmente em pipelines de CI/CD e sistemas modulares maiores.",
    "content": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"esModuleInterop\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"sourceMap\": true,\n    \"declaration\": true,\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    \"verbatimModuleSyntax\": true,\n    \"lib\": [\"ES2022\", \"DOM\"],\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"**/*.test.ts\"]\n}",
    "processedAt": "2025-07-01T20:21:42.261Z"
  },
  {
    "path": "src/interface/middleware/error-handler.middleware.ts",
    "sha": "11ca3804e631d8a90052327afa709d77a77e226a",
    "size": 3550,
    "summary": "Este arquivo implementa um middleware de tratamento de erros para aplicações construídas com Fastify, focado em capturar, categorizar e responder adequadamente a diferentes tipos de erros que podem ocorrer durante o processamento de requisições HTTP. Ele define classes customizadas para erros de domínio, como NotFoundError, UnauthorizedError e LimitExceededError, facilitando a padronização das respostas de erro. O handler centraliza a lógica para identificar erros de validação (Zod e Fastify), erros de domínio, erros HTTP com status code específico e erros genéricos, garantindo respostas estruturadas e consistentes, além de realizar logging detalhado para facilitar o monitoramento e debugging, especialmente em ambiente de desenvolvimento.",
    "content": "import type { FastifyError, FastifyReply, FastifyRequest } from 'fastify';\nimport { ZodError } from 'zod';\n\n/**\n * Classe de erro customizada para erros de domínio\n */\nexport class DomainError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly statusCode: number = 400\n  ) {\n    super(message);\n    this.name = 'DomainError';\n  }\n}\n\n/**\n * Classe de erro para recursos não encontrados\n */\nexport class NotFoundError extends DomainError {\n  constructor(resource: string) {\n    super(`${resource} not found`, 'NOT_FOUND', 404);\n  }\n}\n\n/**\n * Classe de erro para operações não autorizadas\n */\nexport class UnauthorizedError extends DomainError {\n  constructor(message: string = 'Unauthorized') {\n    super(message, 'UNAUTHORIZED', 401);\n  }\n}\n\n/**\n * Classe de erro para limites excedidos\n */\nexport class LimitExceededError extends DomainError {\n  constructor(message: string) {\n    super(message, 'LIMIT_EXCEEDED', 413);\n  }\n}\n\nexport async function errorHandler(\n  error: FastifyError | Error,\n  request: FastifyRequest,\n  reply: FastifyReply,\n): Promise<void> {\n  // Log estruturado do erro\n  request.log.error({\n    error: {\n      message: error.message,\n      name: error.name,\n      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined,\n    },\n    request: {\n      method: request.method,\n      url: request.url,\n      id: request.id,\n    },\n  });\n\n  // Erros de validação Zod\n  if (error instanceof ZodError) {\n    await reply.status(400).send({\n      success: false,\n      error: 'Validation error',\n      code: 'VALIDATION_ERROR',\n      details: error.errors.map((e) => ({\n        path: e.path.join('.'),\n        message: e.message,\n        type: e.code,\n      })),\n    });\n    return;\n  }\n\n  // Erros de domínio customizados\n  if (error instanceof DomainError) {\n    await reply.status(error.statusCode).send({\n      success: false,\n      error: error.message,\n      code: error.code,\n    });\n    return;\n  }\n\n  // Erros de validação do Fastify\n  if ('validation' in error && error.validation) {\n    await reply.status(400).send({\n      success: false,\n      error: 'Validation error',\n      code: 'VALIDATION_ERROR',\n      details: error.validation,\n    });\n    return;\n  }\n\n  // Erros com status code específico\n  if ('statusCode' in error && error.statusCode) {\n    const statusCode = error.statusCode as number;\n    \n    // Mapeamento de códigos HTTP para códigos de erro\n    const errorCodes: Record<number, string> = {\n      400: 'BAD_REQUEST',\n      401: 'UNAUTHORIZED',\n      403: 'FORBIDDEN',\n      404: 'NOT_FOUND',\n      405: 'METHOD_NOT_ALLOWED',\n      408: 'REQUEST_TIMEOUT',\n      413: 'PAYLOAD_TOO_LARGE',\n      429: 'TOO_MANY_REQUESTS',\n      500: '[REDACTED]',\n      502: 'BAD_GATEWAY',\n      503: 'SERVICE_UNAVAILABLE',\n      504: 'GATEWAY_TIMEOUT',\n    };\n\n    await reply.status(statusCode).send({\n      success: false,\n      error: error.message,\n      code: errorCodes[statusCode] || 'UNKNOWN_ERROR',\n    });\n    return;\n  }\n\n  // Erro de timeout\n  if (error.message && error.message.toLowerCase().includes('timeout')) {\n    await reply.status(408).send({\n      success: false,\n      error: 'Request timeout',\n      code: 'REQUEST_TIMEOUT',\n    });\n    return;\n  }\n\n  // Erro genérico - Internal Server Error\n  await reply.status(500).send({\n    success: false,\n    error: 'Internal server error',\n    code: '[REDACTED]',\n    message: process.env.NODE_ENV === 'development' ? error.message : undefined,\n  });\n}",
    "processedAt": "2025-07-01T20:21:44.227Z"
  }
]